# Transaction Basic



데이터를 저장할 때 단순히 파일에 저장해도 되는데, 데이터 베이스에 저장하는 이유중 가장 대표적인 이유는 데이터베이스가 트랜잭션이라는 개념을 지원하기 때문이다.

트랜잭션은 '거래'라는 뜻인데, 하나의 거래를 안전하게 처리하도록 보장해주는 것을 뜻한다. A가 B에게 5000원을 계좌이체 한다고 생각해보자. A의 잔고는 5000원이 감소하고, B의 잔고는 5000원 증가해야 한다.

여기서 거래는 2가지 작업이 합쳐져서 하나의 작업으로 동작해야 한다. 2가지 작업은 다음과 같다.

1. A의 잔고를 5000원 감소
2. B의 잔고를 5000원 증가

둘 중 하나만 성공하면 심각한 문제가 발생한다. 성공하려면 둘 다 성공하던지, 둘 다 실패하던지 해야한다.

데이터베이스가 제공하는 트랜잭션을 이용하면 둘다 함께 성공해야 저장하고, 하나라도 실패하면 그 전의 상태로 돌아갈 수 있다. 모든 작업이 성공해서 DB에 정상 반영하는 것을 커밋이라 하고, 하나라도 실ㄹ패해서 거래 이전으로 되돌리는 것을 롤백이라 한다.



### 트랜잭션 ACID

- 원자성: 트랜잭션 내에서 실행한 작업들은 마치 하나의 작업인 것처럼 모두 성공하거나 모두 실패해야 한다.
- 일관성: 모든 트랜잭션은 일관성 있는 DB 상태를 유지해야 한다. DB에서 정한 무결성 제약 조건을 항상 만족해야 한다.
- 격리성: 동시에 실행되는 트랜잭션이 서로에게 영향을 미치도록 격리한다.
- 지속성: 트랜잭션을 성공적으로 끝내면 그 결과가 항상 기록되어야 한다. 중간에 시스템에 문제가 발생해도 데이터베이스 로그 등을 사용해서 성공한 트랜잭션 내용을 복구해야 한다.

격리성을 제외하고는 큰 문제가 없는데, 격리성이 문제가 된다. 완벽하게 보장하려면 트랜잭션을 거의 순서대로 실행해야 하는데, 동시 처리 성능이 매우 나빠질 수 밖에 없다.



트랜잭션 격리 수준

- READ UNCOMMITTED
- READ COMMITED


- REPEATABLE READ
- SERIALIZABLE



**READ UNCOMMITTED**

커밋하지 않은 데이터를 읽을 수 있다. 트랜잭션 1이 데이터를 수정하고 있는데 커밋하지 않아도 트랜잭션 2가 수정중인 데이터를 조회할 수 있다. 이를 Dirty read라고 하는데, 트랜잭션 2가 이 데이터를 사용중에 트랜잭션 1이 롤백한다면 데이터 정합성에 심각한 문제가 발생한다.



**READ COMMITTED (보통 기본 값)** 

커밋한 데이터만 읽을 수 있다. 하지만 NON-REPEATABLE READ는 발생할 수 있다. 예를 들어 트랜잭션 1이 회원 A를 조회 중인데, 그 때 트랜잭션 2가 회원 A를 수정하고 커밋하면 트랜잭션 1이 다시 회원 A를 조회했을 때 수정된 데이터가 조회된다. 이처럼 반복해서 같은 데이터를 읽을 수 없는 상태이다.



**REPEATABLE READ**

반복해서 조회해도 같은 데이터가 발생할 수 있다. 하지만 PHANTOM READ는 발생할 수 있다. 예를 들어 트랜잭션 1이 10살 이하의 회원을 조회했는데 트랜잭션 2가 5살 회원을 추가하고 커밋하면 트랜잭션 1이 다시 조회했을 때 회원 하나가 추가된 상태로 조회된다. 이처럼 결과 집합 자체가 달라지는 것을 말한다.



**SERIALIZABLE**

가장 엄격한 트랜잭션 격리 수준이며, 위에 나온 모든 것을 허용하지 않는다. 대신 동시성 처리 성능이 급격하게 떨어질 수 있다.



### 데이터베이스 연결 구조와 DB세션

사용자는 WAS나 DB접근 툴 같은 클라이언트를 사용해서 DB 서버에 접근할 수 있다. 클라이언트는 ㅇB 서버에 연결을 요청하고 커넥션을 맺게 된다. 이때 DB 서버는 내부에 세션이라는 것을 만든다. 그리고 앞으로 해당 커넥션을 통한 모든 요청은 이 세션을 통해서 실행하게 된다.

즉 SQL을 보내면 세션이 SQL을 실행한다. 세션이 트랜잭션을 시작하고 커밋 또는 롤백을 통해 트랜잭션을 종료한다. 그리고 이후에 새로운 트랜잭션을 다시 시작할 수 있으며, 커넥션을 닫거나 DBA가 세션을 강제로 종료하면 세션은 종료된다.



**트랜잭션 사용**

데이터 쿼리를 실행하고 결과를 반영하려면 커밋 명령어인 `commit`을 호출하고, 결과를 반영하고 싶지 않으면 `rollback`을 호출하면 된다. 그냥 적용이 되었다면, 오토커밋모드일 가능성이 높다. 참고로 계좌이체와 같은 상황은 꼭 수동 커밋 모드를 사용해서 수동으로 커밋, 롤백할 수 있도록 해야한다. 보통 자동 커밋모드에서 수동 커밋 모드로 전환하는 것을 트랜잭션을 시작한다고 표현한다.

커밋을 호출하기 전까지는 임시로 데이터를 저장하며, 해당 트랜잭션을 시작한 세션에게만 변경데이터가 보이고 다른 세션에게는 변경된 데이터가 보이지 않는다.

서로 다른 세션에서 테스트 해보기 위해서 브라우저로 h2를 접속할 때 새로운 탭으로 들어가면 jsessionid값이 바뀐다. 이를 이용해서 테스트해볼 수 있다.



### DB 락

세션 1이 트랜잭션을 시작하고 데이터를 수정하는 동안 아직 커밋을 수행하지 않았는데, 세션 2에서 동시에 같은 데이터를 수정한다고 생각해보자. 너무 많은 문제가 발생할 수 있다. 이런 문제를 방지하려면 세션이 트랜잭션을 시작하고 데이터를 수정하는 동안에는 커밋이나 롤백 전까지 다른 세션에서 데이터를 수정할 수 없게 막아야 한다.

그래서 DB이는 이런 문제를 해결하기 위해 락(Lock)이라는 개념을 제공한다. 세션 1이 트랜잭션을 시작하고 수정을 할 때 락을 가져온다. 락이 없다면 대기를 해야 한다. 락이 돌아올 때까지 대기를 해야하며 이 대기 시간은 특정 시간이 넘어가면 락 타임아웃 오류가 발생한다. 세션 1이 커밋을 하는 순간 락도 반납을 한다.

결과적으로 하나의 로우를 동시에 수정하는 것은 안된다.

**조회**

일반적인 조회는 락을 사용하지 않는다. 물론 DB마다 다르지만 보통 데이터를 조회할 때는 락을 획득하지 않고 바로 데이터를 조회할 수 있다. 예를 들어 세션 1이 락을 획득하고 데이터를 변경하고 있어도, 세션 2에서 데이터를 조회할수는 있다. 조회가 아니라 변경할 때 락이 필요하기 때문이다.

만약 조회할 때도 락을 획득하고 싶다면 `select for update`구문을 사용하면 된다. 이러면 조회시점에 락을 가져간다. 그리고 커밋하면서 락을 반납한다.

그렇다면 조회 시점에 락이 필요한 경우는 언제일까?

- 트랜시점 종료 시점까지 해당 데이터를 다른 곳에서 변경하지 못하도록 강제로 막아야할 때

금액과 관련된 정보는 매우 중요한 계산이라 꼬이면 안된다. 이럴땐 락을 가져오면서 조회할 수 있다.



### 낙관적 락과 비관적 락

낙관적 락은 이름 그래도 트랜잭션 대부분은 충돌이 발생하지 않는다고, 낙관적으로 가정하는 방법이다. 이것은 DB가 제공하는 락 기능을 사용하는 것이 아니라 JPA가 제공하는 버전 관리 기능을 사용한다. 애플리케이션이 제공하는 락이다. 낙관적 락은 트랜잭션을 커밋하기 전까지는 트랜잭션의 충돌을 알 수 없다.

비관적 락은 트랜잭션의 충돌이 발생한다고 가정하고 우선 락을 걸고 보는 방법이다. 이는 DB가 제공하는 락 기능을 사용한다. 대표적으로 `select for update`같은 구문이 있다.

여기에 더해 트랜잭션 범위를 넘어서는 문제도 있다. 두명의 사용자가 같은 데이터를 수정하고 있다고 해보자. DB에서는 동시 수정을 막지만, JPA를 이용하면 둘 다 데이터를 가져와서 수정할지 안할지 모르니, 먼저 조회를 하고 수정할 수 있다. 물론 쿼리에서 동시작업은 막히겠지만 말이다. 근데 이렇게 수정이 가능하면 둘 다 수정완료를 눌렀을 때 먼저 수정완료를 누른 사람의 데이터는 사라진다. 이것을 **두 번의 갱신 분실 문제**라고 한다.

이 문제는 트랜잭션의 범위를 넘어서는 문제이기에 트랜잭션만으로 해결할 수 없다. 3가지 선택방법이 있다.

- 마지막 커밋만 인정하기
- 최초 커밋만 인정하기
- 충돌하는 갱신 내용 병합하기

기본은 마지막 커밋만 인정하기가 사용되는데, 상황에 따라 최초 커밋만 인정하는게 합리적일 수 있다. 그리고 JPA가 제공하는 버전 관리 기능을 사용하면 손쉽게 변환할 수 있다. 병합하는 방법은 좀 더 우아하게 처리하는 방법인데 그 방법을 애플리케이션 개발자가 직접 제공해야 한다.



#### @Version

JPA가 제공하는 낙관적 락을 사용하려면 @Version 어노테이션을 사용해서 버전 관리 기능을 추가해야 한다. 그리고 이 애너테이션을 적용할 수 있는 타입은 다음과 같다.

- `Long` (long)
- `Integer` (int)
- `Short` (short)
- `Timestamp`

버전 관리 기능을 적용하려면 다음과 같이 버전 관리용 필드를 하나 추가하고 `@Version`을 붙이면 된다. 그러면 엔티티를 수정할 때 마다 버전이 하나씩 자동으로 증가한다. 그리고 엔티티를 수정할 때 조회 시점의 버전과 수정 시점의 버전이 다르면 예외가 발생한다.

```java
@Entity
public class Board {
  @Id
  private long id;
  
  @Version
  private Integer version;
}
```

이렇게 버전 정보를 사용하면 최초 커밋만 인정하기가 적용된다. 어떤 데이터를 커밋할 때 버전정보를 1만큼 증가시킨다. 그리고 버전을 사용하는 엔티티면 조회할 때도, 업데이트할 때도 버전정보를 쿼리에 넣는다.

```sql
UPDATE BOARD
SET
	TITLE=?,
	VERSION=?
WHERE
	ID=?
	AND VERSION=?
```

만약 업데이트를 날렸으면 버전 1만큼 증가시켜야 하는데 만약 누군가가 먼저 수정완료해서 커밋을 날렸다면 버전이 1증가했으므로 조회했을때 조회 대상이 없다. 조회 대상이 없으면 버전이 이미 증가한 것으로 판단하여 JPA가 예외를 발생시킨다. 그리고 `@Version`으로 추가한 버전 관리 필드는 JPA가 직접 관리하므로 개발자가 임의로 수정하면 안 된다. 만약 버전 값을 강제로 증가하려면 특별한 락 옵션을 선택하면 된다.

참고로 벌크 연산은 버전을 무시한다. 벌크 연산에서 버전을 증가하려면 버전 필드를 강제로 증가시켜야 한다.



### JPA 락 사용

JPA를 사용할 때 추천하는 전략은 <u>READ COMMITED 트랜잭션 격리 수준 + 낙관적 버전 관리</u>다.

락은 조회하면서 즉시 걸 수 있다.

```java
Board board = em.find(Board.class, id, LockModeType.OPTIMISTIC);
```

또는 필요할 때 락을 걸 수도 있다.

```java
em.lock(board, LockModeType.OPTIMISTIC);
```

락 옵션은 OPTIMISTIC이 낙관적 락, PESSIMISTIC이 비관적 락이다. 나머지 옵션은 필요하면 찾아보자.

JPA의 낙관적 락은 버전을 사용하며, `@Version`만 있어도 락 옵션을 설정하지 않아도 낙관적 락이 적용된다. 다만 락 옵션을 사용하면 락을 더 세밀하게 제어할 수 있다.

만약 락옵션을 적용하지 않으면, 수정할 때 다른 트랜잭션에 의해 변경되지 않아야 하는 정도를 보장하지만 만약 OPTIMISTIC을 적용하면 엔티티를 조회만 해도 버전을 체크하는 차이가 있다. 조회만하고  커밋했을 때 시작 버전이 다르면 예외가 발생하는 것이다.



DB 트랜잭션을 사용하는 경우를 생각해보자.

```java
public void accountTransfer(String fromId, String toId, int money) throws SQLException {
  // 트랜잭션 시작
  Member fromMember = memberRepository.findById(fromId);
  Member toMember = memberRepository.findById(toId);

  memberRepository.update(fromId, fromMember.getMoney() - money);
  validate(toMember);
  memberRepository.update(toId, toMember.getMoney() + money);
  // 트랜잭션 종료
}
```

중간에 `validate(toMember)`에서 예외가 발생할 수 있는 코드라고 가정해보자. 이 코드에서 만약 예외가 터지면 밑에 부분이 실행이 안될 것이다. 그러면 안된다. 당연히 예외가 터졌는데, 실행해도 문제다. 모든 예외를 잡을 수 없기 때문이다. 어떤 사이드 이펙트가 발생할지 모른다. 그래서 되돌려야 하는데, 돌리는 부분은 전체가 되어야 한다. 모두 롤백 해야한다. 근데 트랜잭션을 시작하려면 커넥션이 필요하다. 그리고 마무리할 때 커넥션을 종료할 것이므로 트랜잭션을 사용하려면 <u>트랜잭션을 사용하는 동안 같은 커넥션을 유지</u>해야 한다. 그래야 같은 세션을 사용할 수 있기 때문이다.

그래서 애플리케이션에서 같은 커넥션을 유지하려면 제일 쉬운 방법은 커넥션을 파라미터로 넘겨서 같은 커넥션이 사용되도록 유지하는 것이다. 그래서 비즈니스 로직을 실행할 때, 오토커밋을 false로 바꿔주고, 커넥션을 파라미터로 받아 진행하다가 예외가 터지면 rollback을 하면된다. 다만 주의할 점은 오토커밋 모드는 false로 바꿔줘야 한다. 이게 종료한다고 커넥션을 끊는게 아니라 커넥션 풀로 돌아가기 때문이다.