# Spring Exception



### 체크 예외와 인터페이스

서비스 계층은 가급적 특정 구현 기술에 의존하지 않고, 순수하게 유지하는 것이 좋다. 이렇게 하려면 예외에 대한 의존도 함께 해결해야 한다. 어차피 서비스 계층은 `SQLException`을 해결할 수 없다. 그래서 리포지토리가 이 예외를 체크 예외를 런타임 예외로 전환해서 서비스 계층에 던지자. 그러면 서비스 계층은 해당 예외를 무시하면 된다.

그리고 이젠 종속성을 없애고 DI를 이용하기 위해 인터페이스를 설계하자. 근데 인터페이스를 하려면 체크 예외가 문제가 된다. 체크 예외를 사용하려면 인터페이스에도 체크 예외가 선언되어야 한다. 인터페이스의 메서드에도 `throws SQLException` 이라는 부분이 붙어야 한다. 붙이는 순간 다시 인터페이스를 붙이는 의미가 없다. 인터페이스가 순수하지 않기 때문이다. 다시 JDBC에 종속적으로 되는 것이다. 

그러려면 인터페이스에는 예외를 안 던지고, 이용하는 리포지토리는 이 `SQLException`같은 체크 예외를 언체크 예외로 전환해서 던져야 한다.

여기서 `SQLException` 중에서도 어떤 문제가 발생했느냐에 따라 **처리하고 싶은 오류**가 있을 수 있다. 키 중복이나 null문제 등 그런 여러 오류들이 데이터베이스마다 코드를 정의해놨다. 이러한 코드는 데이터베이스마다 다르므로, 이런 키를 확인해서 그 키에 맞는 예외를 생성해서 그 예외를 던지면 된다.

근데 위와 같이 문제를 해결하면 나중에 디비 바꿀 땐 엄청 문제가 될 것 같다. 그런 경우는 흔하지 않지만, 코드도 썩 보기 좋은 코드도 아닐 것 같다. 어떻게 해결할 수 있을까?



### 스프링 예외 추상화

스프링은 데이터 접근 계층에 대해 수십가지 예외를 정리해서 일관된 예외 계층을 제공한다. 각각의 예외는 특정 기술에 종속적이지 않게 설계되어 있다. 따라서 서비스 계층에서도 스프링이 제공하는 예외를 사용하면 된다. 예외의 최고 상위는 `DataAccessException`이다. 이는 런타임 예외를 상속받아서 나머지도 모두 런타임 예외다.

이 `DataAccessException`을 상속받은 예외는 크게 2가지로 분류할 수 있다.

- `Transient`: 일시적이라는 뜻으로, 이 하위 예외는 다시 시도했을 때 성공할 가능성이 있다.
  - 예를 들어 쿼리 타임아웃, 락과 관련된 오류들이며 이런 오류들은 데이터베이스 상태가 좋아지거나 락이 풀리면 성공할 수 있다.
- `NotTransient`: 일시적이지 않아서 다시해도 실패한다.
  - 문법오류, 데이터베이스 제약조건 위배 등이 있다.

스프링은 예외 변환기를 제공한다.

`SQLErrorCodeSQLExceptionTranslator` 를 통해서 `translate`메서드를 이용하면 `DataAccessException`을 반환받을 수 있다.



### JDBC Template

위와 같이 짜면 다시 반복되는 코드가 만들어질 것이다. 이를 해결하는게 바로 템플릿 콜백패턴이다.

이는 스프링 고급에서 학습했으니 생략한다.