# Operators



Publisher와 Subscriber가 연결이 된 이후에는, 결과적으로 Data를 날리게 된다. 근데 그냥 Data를 날리지 않고 중간에 Data는 Operator를 거쳐서 가공된 Data로 변경될 수 있고, 계속 흐름이 이어갈 수 있다. 그리고 Operator는 몇개를 거쳐도 상관이 없으며, Stream과 유사하다.

그래서 이 중간에 있는 Operator를 만들어보고자 한다. Publisher와 Subscriber는 다음 기본구조를 사용한다.

```java
public class OperatorTest {

	Logger log = (Logger) LoggerFactory.getLogger(OperatorTest.class);

	@Test
	void basic() {
		Iterable<Integer> iter = Stream.iterate(1, a -> a + 1).limit(10).collect(toList());

		Publisher<Integer> publisher = getPublisher(iter);
		publisher.subscribe(logSubscriber());
	}

	private Subscriber<Integer> logSubscriber() {
		return new Subscriber<>() {
			@Override
			public void onSubscribe(Subscription s) {
				log.debug("Subscription");
				s.request(Long.MAX_VALUE);
			}

			@Override
			public void onNext(Integer integer) {
				log.debug("onNext={}", integer);
			}

			@Override
			public void onError(Throwable t) {
				log.error(t.getMessage(), t);
			}

			@Override
			public void onComplete() {
				log.debug("onComplete");
			}
		};
	}

	private Publisher<Integer> getPublisher(Iterable<Integer> iter) {
		return sub -> sub.onSubscribe(new Subscription() {
			@Override
			public void request(long n) {
				try {
					iter.forEach(sub::onNext);
					sub.onComplete();
				} catch (Throwable t) {
					sub.onError(t);
				}
			}

			@Override
			public void cancel() {

			}
		});
	}
}
```

그리고 이제 체이닝 형식으로 만들기 위해서는, Publisher -> mapper -> mapper -> Subscriber 구조가 될텐데, 이 mapper 역시 Publisher로 만들어야 하며, onNext에 적용할 함수를 가로채면 된다. 물론 다른 함수도 바꿔도 된다. 근데 onNext말고 별 다르게 바꿀 일이 없다면 기본 클래스를 하나 빼서 디폴트 메서드를 사용하면 된다.

디폴트 메서드

```java
public class DelegateSub implements Subscriber<Integer> {

	private final Subscriber sub;

	public DelegateSub(Subscriber sub) {
		this.sub = sub;
	}

	@Override
	public void onSubscribe(Subscription s) {
		sub.onSubscribe(s);
	}

	@Override
	public void onNext(Integer integer) {
		sub.onNext(integer);
	}

	@Override
	public void onError(Throwable t) {
		sub.onError(t);
	}

	@Override
	public void onComplete() {
		sub.onComplete();
	}
}
```

그리고 체이닝으로 다음과 같이 구현할 수 있다.

```java
public class OperatorTest {

	Logger log = (Logger)LoggerFactory.getLogger(OperatorTest.class);

	/**
	 * pub -> [data1] -> mapPub -> logSub
	 * <- subscribe(logSub)
	 * -> onSubscribe(s)
	 * -> onNext
	 * -> onNext
	 * -> onComplete or onError
	 */

	@Test
	void basic() {
		Iterable<Integer> iter = Stream.iterate(1, a -> a + 1).limit(10).collect(toList());

		Publisher<Integer> publisher = getPublisher(iter);
		Publisher<Integer> mapPub = mapPub(publisher, s -> s * 10);
		Publisher<Integer> minusMapPub = mapPub(mapPub, s -> -s);
		minusMapPub.subscribe(logSubscriber());

	}

	private Publisher<Integer> getPublisher(Iterable<Integer> iter) {
		return sub -> sub.onSubscribe(new Subscription() {
			@Override
			public void request(long n) {
				try {
					iter.forEach(sub::onNext);
					sub.onComplete();
				} catch (Throwable t) {
					sub.onError(t);
				}
			}

			@Override
			public void cancel() {

			}
		});
	}

	private Publisher<Integer> mapPub(Publisher<Integer> publisher, Function<Integer, Integer> function) {
		return sub -> publisher.subscribe(new DelegateSub(sub){
			@Override
			public void onNext(Integer integer) {
				sub.onNext(function.apply(integer));
			}
		});
	}

	private Subscriber<Integer> logSubscriber() {
		return new Subscriber<>() {
			@Override
			public void onSubscribe(Subscription s) {
				log.debug("Subscription");
				s.request(Long.MAX_VALUE);
			}

			@Override
			public void onNext(Integer i) {
				log.debug("onNext={}", i);
			}

			@Override
			public void onError(Throwable t) {
				log.error(t.getMessage(), t);
			}

			@Override
			public void onComplete() {
				log.debug("onComplete");
			}
		};
	}
}
```

중간에 mapPub이 클래스를 상속받아 만든 클래스이다.



만약 모든 데이터의 합을 보여주는 Publisher를 만들고 싶다면 어떻게 해야할까? 먼저 코드부터 보자.

```java
private Publisher<Integer> sumPub(Publisher<Integer> publisher) {
  return sub -> publisher.subscribe(new DelegateSub(sub){
    int sum = 0;
    @Override
    public void onNext(Integer integer) {
      sum += integer;
    }

    @Override
    public void onComplete() {
      sub.onNext(sum);
      sub.onComplete();
    }
  });
}
```

먼저 onNext에서 onNext를 안하면 된다. 꼭 onNext를 거기서 호출할 필요는 없다. 그리고, Complete에서 Next와 Complete을 동시에 호출하면 된다. 꼭 무엇을 어디에 호출할 제한사항이 없으니 이렇게 진행하면 onNext가 올 때마다 여기에 데이터가 쌓일 것이고, **그 전 Publisher**가 완료가 되는 순간 구독자에게 합한 데이터와 완료메시지를 동시에 보내주면 된다.

sum이라는 것을 좀 더 일반화할 수 있다. 일반화도 자바 8 에 있는 stream에 있는 reduce를 생각하면 된다.

```java
private Publisher<Integer> reducePub(Publisher<Integer> pub, int init, BiFunction<Integer, Integer, Integer> func) {
  return sub -> pub.subscribe(new DelegateSub(sub){
    int result = init;
    @Override
    public void onNext(Integer integer) {
      result = func.apply(result, integer);
    }

    @Override
    public void onComplete() {
      sub.onNext(result);
      sub.onComplete();
    }
  });
}
```

위랑 크게 다르지 않아서 이해하기 어렵지 않을 것이다.

Generic 타입을 써서 조금 더 일반화 해보자.

```java
public class DelegateSub<T> implements Subscriber<T> {

	private final Subscriber sub;

	public DelegateSub(Subscriber<? super T> sub) {
		this.sub = sub;
	}

	@Override
	public void onSubscribe(Subscription s) {
		sub.onSubscribe(s);
	}

	@Override
	public void onNext(T t) {
		sub.onNext(t);
	}

	@Override
	public void onError(Throwable t) {
		sub.onError(t);
	}

	@Override
	public void onComplete() {
		sub.onComplete();
	}
}
```

이렇게 정의해주면 `Integer`아 아니더라도 일반화한 코드로 사용할 수 있다.

여기서 조금 더 일반화 한다면, 사실 반환 타입도 T가 아니여도 상관없다. 물론 T == R일 수도 있다.

```java
public class DelegateSub<T,R> implements Subscriber<T> {

	private final Subscriber sub;

	public DelegateSub(Subscriber<? super R> sub) {
		this.sub = sub;
	}

	@Override
	public void onSubscribe(Subscription s) {
		sub.onSubscribe(s);
	}

	@Override
	public void onNext(T t) {
		sub.onNext(t);
	}

	@Override
	public void onError(Throwable t) {
		sub.onError(t);
	}

	@Override
	public void onComplete() {
		sub.onComplete();
	}
}
```

이런식으로 정의한다면, 시작은 T타입을 받아서 반환은 R타입으로 할 수 있다. 그리고 사용하는 쪽 역시 다음과 같이 할 수 있다.

```java
private <T, R> Publisher<R> mapPub(Publisher<T> pub, Function<T, R> f) {
  return sub -> pub.subscribe(new DelegateSub<T, R>(sub){
    @Override
    public void onNext(T t) {
      sub.onNext(f.apply(t));
    }
  });
}
```

그럼 일반화하여 가능하다.



물론 실제로는 이렇게 직접 만들어 볼 일은 없다. 라이브러리들이 아주 잘 제공해주고 있기 때문이다. 그리고 그 중 하나가 `Reactor`이다.