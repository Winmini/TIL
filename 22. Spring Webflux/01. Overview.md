# Overview



스프링을 공부하면서 비동기 프로그래밍에 대해서 막 눈을 뜨던 찰나, 스프링 웹플럭스가 생각이 났다. 나온지 그렇게 오래되지 않은 기술이라서 더 흥미가 생겨서 공부한 것도 있지만, 단점으로 이런 지식들은 학습한 사람이 적어 공부하기가 힘들다. 스프링 공식 문서를 번역한 [MadPaly](https://madplay.github.io/) 를 보고 공부하였다.

보통 웹 애플리케이션은 스레드 풀을 사용한다. 스레드 풀은 일정한 이용자, 스레드 풀보다 적은 동시 이용자 까지는 큰 문제가 없다. 하지만 그 이상 늘어나는 트래픽으로 대기큐에 요청이 쌓이는 순간 성능은 급격하게 나빠진다. 스레드를 무한히 늘릴 수 없어 어쩔 수 없는 문제인데, Webflux는 적은 수의 스레드로 동시성을 처리한다. 많은 수의 스레드도 버거운데 어떻게 적은 수로 이를 해결할까?

그리고 여기서 말하는 적은 스레드는 정확히 **스레드가 인지하는 코어의 개수**와 일치한다. 웹 플럭스는 애플리케이션이 스레드를 절대 블로킹하지 않는 것으로 가정한다. 즉 여분의 스레드가 필요가 없다.

먼저 이 적은 스레드가 의미가 있으려면 **Asynchronous**해야 하며, **Non-blocking**해야 한다. 안 그래도 스레드 수가 적은데 블라킹으로 인해 스레드가 쉬고 있다면 Spring Webflux는 안쓰느니만 못하다.

그래서 논 블로킹 웹스택이 필요하다. 서블릿 3.1은 논 블로킹 I/O를 위한 API를 제공한다. 다만 이를 사용하면 이제 블로킹 방식의 다른 서블릿 API는 사용하지 못한다. 사용할 수 있다 하더라도 위의 이유로 사용하면 안된다.



헷갈리는 용어 정리부터 해보자. 처음 접할 때 가장 헷갈리는 것이 동기/비동기와 블라킹/논블라킹이다. 확실하게 짚고 넘어가자.

**Blocking / Non-Blocking**

블라킹은 내가 제어권자체를 잃은 것이다. 말이 어려운데, 예를 들어 우리가 다음과 같은 코드가 있다고 해보자. 항상 코드가 있어야 이해가 편하다.

```java
void callA(){
  int a = 1; // 1지점
  int b = 2; // 2지점
  int c = sum(a + b); // 3지점
  System.out.println(c); // 4지점
}

int sum(int a, int b){
  return a + b;
}
```

함수가 실행되는 과정에 2지점까지는 callA에서 잘 실행되고 있다. 그러다가 3지점에 들어서는 순간 **제어권**은 sum에게로 넘어간다. 그리고 sum에 있는 함수가 모두 실행되기 전까지 callA는 4지점으로 갈 수 없다. 즉  그동안 평범하게 짜왔던 것들은 블라킹으로 짠 것이다. 언젠가 sum이 끝나고 **제어권**을 다시 `callA`에게 넘겨주면 다시 **하던 일을 이어서** 한다. 반면에 non blocking은 `Future` 같은 객체를 이용해야 한다.

다음과 같은 코드를 보자. 중간에 `Async`는 잠깐 넘어가고 코드가 이해가 안되더라도 상관 없다.

```java
List<CompletableFuture<List<Store>>> collect = apiQueries.stream()
  .map(query -> CompletableFuture.supplyAsync(() -> openApi.getData(query), executor))
  .collect(toList());
```

이렇게 코드를 진행하면 map에서 `supplyAsync()`가 실행되고 결과가 나오지 않더라도 그냥 밑의 `collect` 로 넘어간다. 이렇게 그냥 결과를 기다리지 않으면 non blocking이다.



**Sync / Async**

Sync와 Async는 누가 결과를 처리했냐라고 얘기하는데 이건 개인적으로 오해의 소지가 있는 것 같다. 항상 호출당한(위에서는 sum) 함수가 결과를 처리했을 것 같다. 개인적으로는 **결과를 어떻게 확인하냐**가 맞는 것 같다. Sync는 보통 동기라고 하고 일상적으로 받아들일 때에도 동기화되었다. 라는 말은 서로 뭔가 어긋나있지 않다 라는 느낌이다. 그리고 그렇게 동기화되려면 끊임없이 Sync를 맞춰주어야 한다. 상대와 나의 Sync를 맞추기 위해선 끊임없이 확인해주어야 한다. 여기서도 마찬가지다 Sync는 함수의 결과가 나왔는지 안나왔는지 호출하는 상대가 끊임없이 확인해주어야 한다.

마땅한 코드가 생각이 나지 않아 다음과 같이 이해하면 좋을 것 같다. Sync는 호출하는 상대가 끊임 없이 확인을 해주어야 한다.

```java
void callA(){
  int a = 1;
  int b = 2;
  Integer c = sum(a + b);
  if(checkSum(c) != null){
    System.out.println(c);
  }
  // 다른 로직
  
  if(checkSum(c) != null){
    System.out.println(c);
  }
  // 다른 로직
  
  if(checkSum(c) != null){
    System.out.println(c);
  }
  // 다른 로직
}

int sum(int a, int b){
  return a + b;
}
```

null 아니라면 3번 호출되는 그런건 무시하고 그냥 이해만 하자. 내가 계속 확인을 해주면서 떴는지 안떴는지 확인해주면서 할일을 한다. 그리고 결과가 떴다면 받아서 바로 처리한다.

그런 의미에서 자기 하던 일을 하다가 결과를 처리하고 싶을 때마다, 결과가 나왔는지 안나왔는지 확인을 하는 것이다. 그리고 결과를 **처리하고 싶을 때마다 결과가 나왔는지 안나왔는지 확인한 것**이라서 받으면 바로 처리하는 것이 맞다.

 Async는 비동기다. 더 이상 씽크를 맞추지 않아도 된다. 그냥 호출한 함수는 하던 일을 계속한다. 언젠가 결과가 나오면 그제서야 호출한 함수를 `Callback` 해줄 것이다. 그러면 호출한 함수는 그 Callback을 통해 그 결과를 **처리하고 싶을 때** 처리하면 된다. 내 하던 일이 있으니 굳이 바로 처리할 필요가 없다. 그냥 하고 싶을 때 하면 된다.



**Reactive**

리액티브란 어떤 이벤트, 혹은 변화에 대한 **반응**이라고 생각하면 될 것 같다. 따라서 리액티브 프로그래밍이란 변화에 반응하는 방식으로 짠 프로그래밍이다.



**Back pressure**

기존의 동기식이나, 명령형 코드, 블로킹 호출은 호출자를  대기하게 하는 자연스러운 형태의 백프레셔 역할을 한다. 논 블로킹은 생산자와 소비자의 데이터 흐름이 중요해지며, 이는 이벤트 속도를 제어하는 것이 중요하다.

리액티브 스트림의 주요 목적은 구독자를 통해 발행자가 데이터를 어느 정도로 생산할지 제어하도록 하는 것이다. 그를 도와주는 것이 Back pressure이다.



**Reactive API**

애플리케이션은 비동기 로직을 구성하기 위하여 더 높고 풍부한 함수형 API를 필요로 하며, 이는 자바 8의 `stream` API와 유사하지만 **컬렉션에 대해서만 필요한 것이 아니다.** 이 것이 리액티브 라이브러리의 역할이다. 스프링 웹플럭스가 선택한 리액티브 라이브러리는 리액터(Reactor)이다. 리액터는 ReactiveX의 연산자의 어휘와 풍부한 연산자 세트를 통해 Mono와 Flux API 유형을 제공한다. 그리고 모든 리액터 연산자는 논블로킹 백프레셔를 지원한다.



### 프로그래밍 모델

그 동안 사용한 Spring Web 모듈에는 HTTP 추상화, 지원되는 서버를 위한 리액티브 스트림 어댑터, 코덱, 그리고 서블릿 API와 유사하지만 논 블로킹 계약을 포함하는 핵심 WebHandler API를 포함하여 스프링 웹 플럭스의 근본이 되는 리액티브 기반이 포함되어 있다.

이해가 안되어도 일단 진행하자.

- 어노테이션 컨트롤러: 스프링 MVC와 일치한다. 스프링 MVC와 웹플럭스 컨트롤러는 리액티브 반환타입을 지원하므로 구분하기 쉽지 않다.
- 함수형 엔드포인트: 람다 기반의 가벼운 함수형 프로그래밍 모델이다. 애플리케이션이 요청을 라우팅하고 처리하는데 사용할 수 있는 작은 라이브러리 또는 유틸리티 집합이다. 어노테이션 컨트롤러와의 차이점은 애플리케이션이 어노테이션을 통해 의도를 선언하고 콜백을 받는 것과 다르게 요청을 처음부터 끝까지 처리한다는 점이다.



### 적용 가능성

스프링 MVC인가 Webflux인가

개발에는 항상 정답이 없다. 상황에 따라 다르다는 말밖에 할 수가 없고 어떤 상황에 적합한지 스프링 문서에서 제안을 해준다.

- 제대로 동작하는 스프링 MVC 애플리케이션이라면 변경할 필요가 없다. 명령형 프로그래밍은 코드를 작성하고, 이해하고, 디버깅하는 가장 쉬운 방법이다. 그리고 대부분 라이브러리가 블로킹 방식이기 때문에 라이브러리를 선택할 때 많은 선택권을 갖게 된다.
- 논 블로킹 웹 스택을 고려하고 있다면, 스프링 웹플럭스는 다른 웹 스택과 동일한 실행 모델 이점을 제공하며 서버(네티, 톰캣, 제티, 언더토우, 서블릿 3.1+컨테이너), 프로그래밍 모델, 리액티브 라이브러리(Reactor, RxJava)에 대한 선택지를 제공한다.
- 자바 8의 람다 또는 코틀린과 함께 사용할 함수형 웹 프레임워크를 찾는다면, 스프링 웹플럭스는 함수형 웹 엔드포인트를 사용할 수 있다. 또한 소규모의 애플리케이션이나 더 큰 명료함과 제어를 더 적은 복잡도로 제공하는 **마이크로 서비스에 좋은 선택**이 될 수 있다.
- 마이크로 서비스 아키텍처에서 스프링 MVC는 스프링 웹 플럭스 컨트롤러 또는 스프링 웹 플럭스 함수형 엔드포인트로 만들어진 애플리케이션을 혼합하여 사용할 수 있다. 두 프레임워크에서 동일하게 어노테이션 기반 프로그래밍 모델을 지원하는 점은 지식을 더 쉽게 사용할 수 있다.
- 애플리케이션을 평가하는 간단한 방법은 애플리케이션의 의존성(dependencies)를 확인하는 것이다. 블로킹 퍼시스턴스(persistence) API 또는 네트워킹 API를 사용하고 있다면 적어도 공통 아키텍처에는 스프링 MVC가 가장 적합하다. 스프링 MVC는 개별 스레드에 리액터(Reactor)와 RxJava를 사용하여 블로킹 호출을 실행할 수 있지만 논 블로킹 웹 스택을 최대한으로 활용하지 못한다.
- 원격 서비스를 호출하는 스프링 MVC 애플리케이션인 경우 리액티브 `WebClient`를 사용해보자. 스프링 MVC 컨트롤러 메서드에서 리액티브 타입(Reactor, RxJava)을 직접 반환할 수 있다. 호출당 대기시간이 길거나 호출 간 상호 의존성도가 높을수록 이점을 얻을 수 있다. 팀의 규모가 크다면 전체를 전환하지 않고 시작하는 실용적인 방법이기도 하다.



