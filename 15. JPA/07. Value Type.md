# Value Type



JPA는 데이터 타입을 최상위 레벨로 보면 2가지로 분류한다. 엔티티 타입과 값 타입이다.



지금 껏 했던 타입은 엔티티 타입이다.

- 엔티티 타입
  - @Entity로 정의하는 객체
  - 데이터가 변해도 식별자로 지속해서 추적가능
  - 우리가 회원 엔티티의 키나 나이값을 변경해도 ID로 인식 가능하다.

이제 공부할 타입은 값 타입이다.

- 값 타입
  - int, Integer, String처럼 단순히 값으로 사용하는 자바 기본 타입이나 객체
  - 식별자가 없고 값만 있으므로 변경시 추적 불가
  - 숫자 100을 200으로 변경하면 완전히 다른 값으로 대체한다.



#### 값 타입 분류

- 기본값 타입
  - 자바 기본 타입(int, double)
  - 래퍼 클래스(Integer, Long)
  - String
- 임베디드 타입
  - JPA에서 정의를 해야함
  - x, y좌표같이 뭔가 묶어서 우리가 만드는 그런 값들
  - 주로 기본 값 타입을 모아서 만들어서 복합 값 타입
- 컬렉션 값 타입
  - 자바 컬렉션에 기본 값타입이나 임베디드 타입을 넣을 수 있는 것

기본 값 타입은 생명주기를 엔티티에 의존한다. 회원이라는 엔티티안에 나이, 이름 이런 기본 값 타입들은 회원 엔티티가 삭제될 때 필드는 같이 삭제된다.

**값 타입은 절대로 공유하면 안된다.**

참고로 자바의 기본 타입은 공유가 안된다. 기본 타입은 항상 값을 복사하며 래퍼클래스나 String은 공유 가능하지만 변경은 안된다. 그래서 사이드 이펙트가 발생할 여지가 막혀있다. 그래서 기본 타입은 안전하다.



##### 임베디드 타입

사는 도시, 구, 우편번호 등을 묶어서 주소라는 Value Type을 만들어 낸다고 하면 이게 임베디드 타입이다. 이런 임베디드 타입은 재사용, 높은 응집도 등이 좋다. 임베디드 타입도 결국 값 타입이라, 엔티티 생명주기에 의존한다. 그리고 디비 입장에서는 테이블이 바뀌지 않는다. 다만 객체는 객체지향적으로 설계가 되므로 좋다.

그런데 값 타입이면 값타입이라고 알려줘야 한다. 아니면 이전에 했던 매핑관계와도 혼선이 올 수 있으므로 값타입임을 알려주는 어노테이션을 달자. 값타입에 해당하는 클래스에는 `@Embeddable` 를 넣고, 기본생성자는 필수이다.  사용하는 클래스에는 `Embedded` 를 넣으면 된다. 둘 중 하나는 생략해도 되지만 둘 다 넣는 것을 권장한다.

잘 설계한 ORM 애플리케이션은 테이블의 수보다 클래스의 수가 많다.

---



값타입은 복잡한 객체 세상을 조금이라도 단순화하려고 만든 개념이다. 따라서 값 타입은 안전하고 단순하게 다룰 수 있어야 한다. 그래서 임베디드 타입 같은 값 타입을 여러 엔티티에서 공유하면 위험하다. 회원 1과 회원 2가 같은 값타입을 가지고 있다면 동시에 바꿀 수 있다는 것이다. 이런건 어디서 문제가 됐는지 찾을 수가 없다. 만약 진짜로 공유하고 싶은 거라면 엔티티로 만들었어야 한다. 따라서 값을 복사해서 써야 한다.  근데 공유참조 자체를 막을 수 가 없다. 기본 타입은 값이 복사지만 객체 타입이기에 참조를 전달할 것이다. 근데 이를 막을 방법이 없다.

그래서 <u>값 타입은 수정할 수 없게 만들어야 한다.</u> 즉 불변 객체로 설계헤야 한다. 생성자로만 값을 설정하고 수정자를 만들지 않으면 된다. 그러면 값 변경은 어떻게할까?

당연히 새로 만들어서 넣어야 한다. 이렇게 하는 것이 부작용을 막는 큰 방법이다.

값타입의 비교는 당연 equals와 hashcode둘다 만들어야 한다. 그리고 만드는 건 자동으로 만들어주는 방법을 사용하자.



#### 값 타입 컬렉션

값 타입 컬렉션을 사용할 때엔 @ElementCollection을 사용한다. 기본적으로 일대다 구조에, 멤버 id와 요소로 테이블을 구성해야 엔티티가 아닌 값 타입이 된다. 그리고 새로운 테이블을 만들어야 하기에 @CollectionTable 애노테이션도 사용해야 한다. 사용 예시이다.

```java
@ElementCollection
@CollectionTable(name = "address", joinColumns = @JoinColumn(name = "member_id"))
private List<Address> addressHistory = new ArrayList<>();
```

값 타입을 하나 이상 저장할 때 사용한다.

그리고 위에 어노테이션을 주면 값타입임을 명시한 것이기에, 생명주기와 관리는 해당 엔티티에 의존된다. 영속성 전이와 고아객체 제거 기능을 필수로 갖게되는 것이다. 그리고 컬렉션들은 지연로딩이다. 그리고 당연히 지연로딩이 맞다.

값 수정할 때는 값 타입을 우리가 불변객체로 만들었기 때문에, <u>리스트에서 찾기 위해선 equals가 필수로 구현되어 있어야 한다</u>. 그래서 통으로 비교하여 같은 객체를 찾아 지우고, 새로 넣어야 한다.

그리고 equals같은 걸 구현하다보면 직접 접근하는 것보다 <u>getter로 접근하는게 나중에 프록시를 사용할 때에 이어질 수 있기때문에 훨씬 좋다.</u>

값 타입 컬렉션에 변경사항이 발생하면, 주인 엔티티와 관련된 모든 데이터를 삭제하고, 값 타입 컬렉션에 있는 현재 값을 모두 저장한다. 그래서 많아지면 성능이 저하될 수 있어 상황에 따라 값타입 대신 일대다 관계를 고려해서 엔티티를 그냥 설계해버리는게 나을 수도 있다. 그리고 영속성전이와 고아객체 방지하여 값타입 컬렉션처럼 사용하면 된다. <u>그리고 실무에서도 이 방법을 많이 쓴다.</u>

