# 기초



자바가 보통 8버전부터 가장 큰 변화가 생겼다고 한다. 그 기준이 람다와 스트림에 대한 내용인데, 혼자서 프로그래밍을 하다보면 이를 하나도 응용하지 못하여, 이 저서로 학습하기로 한다.

처음 설명에 나온 코드를 보면

```java
Collections.sort(inventory, new Comparator<Apple>() {
  public int complare(Apple a1, Apple a2){
    return a1.getWeight().compareTo(a2.getWeight());
  }
})
```

이를 자바 8을 이용한다면 다음과 같이 구현할 수 있다고 한다.

```java
inventory.sort(comparing(Apple:getWeight));
```

놀랍게도 위의 있는 코드는 우아한 테크코스과정에 프리코스를 진행할 때, 과제에서 내가 쓰려했던 코드와 아주 유사했고, 이를 보면서 반성도 하였고 시작부터 설레었다.

이는 나중에 배우기로 하고, 어쨌든 강력한 힘을 가지고 있다는 것은 확실했다.

자바 8은 그외에도 많은 것을 제공하였는데, 공짜는 없다. 이러한 기법을 지키기 위해서는 몇가지 규칙을 지켜야 하고, 그 것을 소개한다. 자바 8은 간결한 코드, 멀티코어 프로세서의 쉬운 활용이라는 두가지 요구사항을 기반으로 한다. 일단 자바 8에서 제공하는 새로운 기술이 어떤 것인지 확인하자.

- 스트림 API
- 메서드에 코드를 전달하는 기법
- 인터페이스의 디폴트 메서드

또한 자바 8 기법은 함수형 프로그래밍에서 강력한 위력을 발휘 한다. 이러한 것들에 대해서 배우기 이전에 처음은 가벼운 내용으로 시작하자.



자바 8 설계의 밑바탕을 이루는 세 가지 개념부터 익히자.



##### 스트림 처리

<u>스트림이란</u> 한 번에 한 개씩 만들어지는 연속적인 데이터 항목들의 모임이다. 이론적으로 프로그램은 입력스트림에서 데이터를 한 개씩 읽어 들이며 마찬가지로 출력 스트림으로 데이터를 한 개씩 기록한다. 즉 어떤 프로그램의 출력 스트림은 다른 프로그램의 입력 스트림이 될 수 있다.

자바 8에는 java.util.stream 패키지에 스트림 API가 추가되었다. 스트림 패키지에 정의된 Stream<T>는 T 형식으로 구성된 일련의 항목을 의미한다. 우선은 스트림 API가 조립 라인처럼 어떤 항목을 연속으로 제공하는 어떤 기능이라고 단순하게 생각하자. 

스트림 API의 핵심은 기존에는 한번에 한 항목을 처리했지만, 이제 자바 8에서는 데이터베이스의 질의처럼 고수준으로 추상화해서 일련의 스트림으로 만들어 처리할 수 있다는 것이다. 또한 스트림 파이프라인을 이용하여, 입력 부분을 여러 CPU 코어에 쉽게 할당할 수 있다는 부가적인 이득도 얻을 수 있다. 스레드라는 복잡한 작업을 사용하지 않으면서도 공짜로 **병렬성**도 얻는다.



##### 동작 파라미터화로 메서드에 코드 전달

자바 8에 추가된 두 번째 프로그램 개념은 코드 일부를 API로 전달하는 기능이다. 말이 좀 어려운데, 예를 들어 알아보자 만약 송장 ID가 있고, 그 송장 ID는 2013UK0001, 2014US0002 와 같은 형식을 가진다고 하자. 연도, 국가코드, 고객ID를 합친 새로운 형식의 ID이다. 여기서 우리는 고객ID 혹은 국가 코드순으로 정렬해야 한다고 하자. 만약 sort 명령을 이용하려면 sort가 고객 ID나 국가 코드로 송장 ID를 정렬하도록 sort에 따로 코드를 제공해야 한다. 근데 자바 8 이전에는 메서드를 다른 메서드로 전달할 방법이 없았다. Comparator 객체를 만들어 넘겨주는 방법이 있긴하겠지만 복잡하고, 기존 동작을 단순하게 재활용한다는 측면에서도 좋은 수단이 아니다. 자바 8에서는 메서드를 다른 메서드의 인수로 넘겨주는 기능을 제공한다. 이러한 기능을 <u>동작 파라미터화</u>라고 부른다.



##### 병렬성과 공유 가변 데이터

마지막 개념은 '병렬성을 공짜로 얻을 수 있다'이다. ~~사실 세상에 공짜는 없다.~~ 무엇을 포기해야할까? 스트림 메서드로 전달하는 코드의 동작 방식을 조금 바꿔야 한다. 초반에는 불편하지만, 나중에는 더 선호할 것이다. 또한 다른 코드와 동시에 실행하더라도 안전하게 실행할 수 있는 코드를 만들려면 공유된 가변 데이터에 **접근하지 않아야** 한다. 이러한 함수를 순수 함수, 부작용 없는 함수, 상태 없는 함수라고 부른다.



### 자바 함수

프로그래밍 언어에서 함수라는 용어는 메서드, 특히 정적 메서드와 같은 의미이다. 자바의 함수는 이에 더해 수학적인 함수처럼 사용되며 부작용을 일으키지 않는 함수를 의미한다. 자바8 에서의 함수 사용법은 일반적은 프로그래밍 언어의 함수 사용법과 아주 비슷하다.

함수는 왜 필요할까?

프로그래밍 언어의 핵심은 값을 바꾸는 것이다. 그리고 전톡적으로 프로그래밍 언어에서는 이 값을 일급값(일급 시민)이라고 부른다. 자바 프로그래밍 언어의 다양한 구조체가 값의 구조를 표현하는데 도움이 될 수 있다. 하지만 프로그램을 실행하는 동안 모든 구조체를 자유롭게 전달할 수 없다. 전달할 수 없는 구조체는 이급 시민이다. 메서드, 클래스 등은 이급 자바 시민이다. 왜냐하면 인스턴스화한 결과가 값으로 귀결되는 클래스를 정의할 때 메서드를 아주 유용하게 활용할 수 있지만 여전히 메서드와 클래스는 그 자체로 값이 될 수 없다. 자바 8 설계자들은 이급 시민을 일급 시민으로 바꿀 수 있는 기능을 추가했다.



##### 메서드와 람다를 일급 시민으로

스칼라와 그루비 같은 언어를 사용한 사람들은 메서드를 일급값으로 사용하면 활용이 다양해지며 프로그래밍이 쉬워짐을 이미 경험했다. 또한 이러한 강력한 기능 때문에 익숙해지면 일급 시민이 부족한 다른 언어의 사용을 기피하기도 한다. 그래서 자바 8은 메서드를 값으로 취급할 수 있게 설계하기로 결정하엿다.

첫번째로 메서드 참조라는 새로운 자바 8의 기능을 소개한다. 디렉터리에서 모든 숨겨진 파일을 필터링한다고 가정하자. 우선 주어진 파일이 숨겨져 있는지 여부를 알려주는 메서드를 구현해야 한다. 다행히 File 클래스는 이미 isHidden 메서드를 제공한다. isHidden은 File 클래스를 인수로 받아 boolean을 반환하는 함수다. 다음 예제처럼 FileFilter 객체 내부에 위치한 isHidden의 결과를 File.listFiles 메서드로 전달하는 방법으로 숨겨진 파일을 필터링할 수 있다. 코드를 살펴보자.

```java
File[] hiddenFiles = new File(".").listFiles(new FileFilter()){
  public boolean accept(File file){
    return file.isHidden();
  }
});
```

문제는 완성한 코드가 실망스럽다. 몇줄 안되는 코드인데 무슨 짓을 하는 것인지 알 수가 없다. 왜 저렇게 복잡하게 감싸고 인스턴스화 해야할까? 자바 8 나타나기 전에는 달리 방도가 없었다. 하지만 줄어든 코드는 다음과 같다.

```java
File[] hiddenFiles = new File(".").listFiles(File::isHidden);
```

너무나 깔끔하다. 함수는 이미 준비되어 있으므로 자바 8의 <u>메서드 참조</u> (::, 이 메서드를 값으로 사용하라는 의미)를 이용해서 listFiles에 직접 전달할 수 있다. 여기서 메서드가 아닌 함수라는 용어를 사용했다는 것도 참고하자. 코드가 작동하는 방법은 나중에 설명하며, 강력함만을 또 다시 경험하자.



##### 람다 : 익명 함수

자바 8에서는 메서드를 일급값으로 취급할 뿐 아니라 람다를 포함하여 함수도 값으로 취급할 수 있다. 예를 들어 `(int x) -> x + 1` 즉 'x라는 인수를 호출하면 x + 1을 반환' 이라는 이 동작을 수행하도록 코드를 구현할 수 있다.



##### 코드 넘겨주기

Apple 클래스와 getColor 메서드가 있고, Apples 리스트를 포함하는 변수 inventory가 있다고 가정하자. 이때 모든 사과를 선택해서 리스트를 반환하는 프로그램을 구현하려 한다. 이처럼 특정 항목을 선택해 반환하는 동작을 필터라고 한다. 자바 8 이전의 코드를 보자.

```java
public static List<Apple> filterGreenApples(list<Apple> inventory){
  List<Apple> result = new ArrayList<>();
  
  for (Apple apple: inventory){
    if (GREEN.equals(apple.getColor())){
      result.add(apple);
    }
  } return result;
}
```

만약 근데 누군가가 사과를 무게로 필터링하고 싶다고 하자 그럼 그 코드를 구현하기 위해서 아마 복사 붙여넣기를 통해 다음과 같이 구현할 수 있다.

```java
public static List<Apple> filterGreenApples(list<Apple> inventory){
  List<Apple> result = new ArrayList<>();
  
  for (Apple apple: inventory){
    if (apple.getWeight() > 150){
      result.add(apple);
    }
  } return result;
}
```

복사 붙여넣기의 단점은 치명적이다. 하나의 코드에서 버그가 발생하면 모든 코드를 다 수정해야한다. 다행히 이역시 자바 8에서는 다르게 처리할 수 있다.

```java
public static boolean isGreenApple(Apple apple){
  return GREEN.equals(apple.getColor());
}

public static boolean isHeavyApple(Apple apple){
  return apple.getWeight() > 150;
}

public interface Predicate<T>{
  boolean test(T t);
}

static List<Apple> filterApples(List<Apple> inventory, Predicate<Apple> p){
  List<Apple> result = new ArrayList<>();
  for (Apple apple: inventory) {
    if (p.test(apple)) {
      result.add(apple);
    }
  } return result;
}
```

이와 같이 정의한 다음 다음 코드면 된다.

```java
filterApples(inventory, Apple::isGreenApple);
filterApples(inventory, Apple::isHeavyApple);
```

훨씬 명료하다.



##### 메서드 전달에서 람다로

메서드를 값으로 전달하는 것은 분명 유용했다. 하지만 `isHeavyApple`, `isGreenApple`처럼 한두 번만 사용할 메서드를 매번 정의하는 것이 귀찮은 일이다. 자바 8에서는 다음처럼 람다라는 새로운 개념을 이용하여 코드를 구현할 수 있다.

```java
filterApples(inventory, (Apple a) -> GREEN.equals(a.getColor()));
filterApples(inventory, (Apple a) -> a.getWeight() > 150);
```

심지어는 이런 것도 가능하다.

```java
filterApples(inventory, (Apple a) -> a.getWeight() < 80 || RED.equals(a.getColor()));
```

즉, 한 번만 사용할 메서드는 따로 정의를 구현할 필요가 없다. 위 코드는 우리가 넘겨주려는 코드를 애써 찾을 필요가 없을 정도로 더 짧고 간결하다. 다만 람다가 몇 줄 이상으로 길어진다면, 복잡한 수행을 해야한다면 명확함이 우선이므로 잘 설명하는 이름을 정해 메서드를 정의하자.

여기서 더 나아가 함수형 프로그래밍까지 얘기해보자. 만약 filter라는 일반적인 라이브러리 메서드를 추가하는 방향으로 <u>발전했다면</u> 다음과 같이 라이브러리 메서드 filter를 사용하여 filterApples 메서드를 구현할 필요가 없다.

```java
filter(inventory, (Apple a) -> a.getWeight() > 150);
```

하지만 이러한 작업은 포기했다. 병렬성이라는 중요성 때문이다. 대신 비슷한 동작을 수행하는 새로운 스트림 API를 제공한다.



### 스트림

거의 모든 자바 애플리케이션은 컬렉션을 만들고 활용한다. 하지만 컬렉션으로 모든 문제가 해결되는 것은 아니다. 스트림 API를 이용하면 해결이 가능하다. 컬렉션에서는 반복과정을 for-each 루프를 이용해 각 요소를 반복하면서 작업을 수행해야 했다. 이런 반복을 외부 반복이라 하며, 스트림 API를 이용하면 루프를 신경 쓸 필요가 없다. 스트림 API에서는 라이브러리 내부에서 모든 데이터가 처리된다. 이와 같은 반복을 내부 반복이라고 한다.

컬렉션을 이용하면 다른 문제도 생길 수 있다. 많은 요소를 가진 목록을 반복하면, 단일 CPU로는 처리하기 힘들 것이다. 보통 멀티코어 컴퓨터를 사용하는 데 각각 할당을 한다면 처리시간도 줄어들고 좋다. 이론적으로는 8개의 코어를 가졌다면 단일에 비해서 8배 빠르다. 



### 디폴트 메서드와 자바 모듈

요즘은 외부에서 만들어진 컴포넌트를 이용해 시스템을 구축하는 경향이 있다. 자바 9의 모듈 시스템은 모듈을 정의하는 문법을 제공한다. 자바 8에서는 인터페이스를 쉽게 바꿀 수 있도록 디폴트 메서드를 지원한다. 컬렉션 API의 인터페이스를 구현하는 많은 컬렉션 프레임워크가 존재하는데, 인터페이스에 새로운 메서드를 추가한다면 구현하는 모든 클래스는 새로 추가된 메서드를 구현해야 한다. 현실적으로 언어 설계자들이 컬렉션 인터페이스를 구현한 모든 코드를 책임질 수 없다. 기존의 구현을 고치지 않고 공개된 인터페이스를 변경할 수 있을까?

결정적으로 자바 8은 구현 클래스에서 구현하지 않아도 되는 메서드를 인터페이스에 추가할 수 있는 기능을 제공하며, 이를 디폴트 메서드라 한다. 예를 들어 자바 8에서는 List에 직접 sort 메서드를 호출할 수 있다. 이는 다음과 같은 디폴트 메서드 정의가 추가되었기 때문이다.

```java
defalut void sort(Comparator<? super E> c){
  Collections.sort(this, c);
}
```

따라서 이젠 디폴트 sort를 구현하지 않아도 된다.

