# 공부했지만 정리해야 하는 내용



CS지식들을 정리할 내용을 아주 대충 적었습니다.

나중에 날잡아서 하나씩 정리하겠습니다.



거품정렬: 앞에서부터 계속 순서를 바꿔가며
선택정렬: 최소값을 찾아 앞에서부터 메꿈
삽입정렬: 2번째부터 앞원소랑 비교하면서 그자리로 삽입함
퀵정렬: 배열중 피벗을 골라 피벗을 기준으로 높고 낮은쪽을 양쪽으로 분할정복, 불안정
병합정렬: 다쪼개놓고 정렬하면서 병합함, 안정
힙정렬: 불안정함, 완전이진트리 기반, 루트를 마지막 노드로 대체, 마지막노드는 밑을 탐색하면서
큰값이랑 계속 위치를 바꿈

 CPU: 연산장치, 제어장치, 레지스터

캐시: 시간지역성, 자주 참조되는애, 공간지역성, 근처에있는애가 금방 사용될가능성 높음
CPU가 요청한 데이터가 캐시에있으면 캐시힛, 없어서 DRAM에서 가져오면 캐시미스

캐시미스 3가지
cold miss : 처음부름
conflict miss: 두 데이터가 같은 메모리주소 할당되어있어 다른곳을 씀
capacity miss: 캐시메모리공간이 부족

direct Mapped cache : conflict 예상

fully associate cache: 비어있으면 아무데나 저장, 찾기가 힘듦

set associative cache: 특정행의 열이 비어있으면 ,거기그냥씀 위 2개의 중간

패리티: 짝수패리티의경우 다더했을때 홀수면 짝수로 맞춰주는 패리티 맨앞에다 더한다.
해밍코드: 1,2,4번비트를 기준으로 홀수 2개씩 4개씩 코드를 꺼내 짝수면0 홀수면 1, 그리고뒤집어서 십진법으로 바꾸면 된다.


Process Management
CPU가 프로세스 여러개일 때, CPU 스케줄링을 통해 관리
CPU는 각 프로세스들으 누군지 알아야하고, 프로세스들의 특징을 갖고있는 것이
Process Memtadata, id, state, priority, CPU registers, Owner, CPU Usage, Memory Usage 등..
프로세스가 생성되면 PCB라는 곳에 저장됨
한 PCB안에는 한 프로세스의 정보가 담김
피씨비가 있어야 CPU프로세스의 상태에 따라 교체작업(인터럽트)이 발생할 때 이 중간 값들을 
PCB에 올려둠,
관리는 LinkedList로 한다.삽입삭제가 용이하다. 프로세스 완료시 PCB제거

IPC: 프로세스는 독립적으로 실행됨 서로 영향을 끼치지 않는다. 스레드는 영향을 끼친다(자원공유하니까)
근데 혹시라도 통신해야하면 도와주는게 IPC통신
프로세스는 커널(운영체제의 핵심적인 부분)이 제공하는 IPC 설비를 이용해 통신함

CPU 스케줄러
FCFS: 먼저온 고객을 먼저 서비스, 비선점형, 소요시간이 긴 프로세스가 먼저 도달하면 효율성 낮춤
 - convoy effect문제!

SJF: CPU burst time이 짧은 프로세스 우선! 비선점형
starvation 문제!

SRTF: 새로운 프로세스가 도착할 떄마다 새로운 스케줄링, 선점형, 수행중인 프로세스의 남은 burst time과 비교

Priority Scheduling 우선순위로 할당 선점과 비선점이 있음 실행을 바꾸냐와 우선순위헤드에 넣냐.
문제점으로 starvation, Indefinite blocking
해결책으로 우선순위가 낮아도 오래기다리면 순위 높여주는 aging

RoundRobin 프로세스는 동일한 크기의 할당시간을 갖게된다. 할당시간이 지나면 프로세스는 선점당하고 큐에 맨뒤로감
RR은 사용시간이 랜덤한 프로세스가 섞여이을때 좋으며 프로세스의 컨텍스트를 세이브할수있음
나름 공정한 스케줄링, 특정시간이상 기다릴 필요없음 근데
time quantum이 너무 커지면 FCFS와 같아진다. 너무 낮으면 이상적이지만 컨텍스트 스위치로 오버헤드

프로세스 동기화문제
Critical Section(임계영역): 충돌나면 안되는 영역
해결로 Mutex Lock 프로세스가 들어갈때 Lock을 얻고 나올때 Lock을 방출

데드락: 세마포가 레디 큐를 가지고 있고, 둘 이상의 프로세스는 크리티컬 섹션을 무한정 기다리며
섹션에 있는 프로세스는 대기중인 프로세스가 실행되어야 빠져나오는 상황..

메모리 관리 전략:
단편화? 압축으로 해결할 수 있지만..영..
페이징으로 위를 해결해보자. 페이지라는 고정크기로 관리 역시 내부 단편화문제



디버깅: 소프트웨어의 문제가 터질 때 잘못된 점을 찾는 것. 따라서 개발중이라고 하기도 함

컴파일: 개발자가 코드짠 것을 출시전에 번역하는게 컴파일

자바: java -> class로 바뀌는 과정

자바스크립트, 파이썬, 루비: 인터프리터 언어, 스크립트 언어 컴파일이 없고 그때그때 처리함. 그래서 조금느리고 코드 유출이 좀 쉬움

빌드: 어마무시한 폴더와 파일, 라이브러리, 이미지 등등 다 모아서 압축하는 과정이 빌드. 컴파일 언어는 여기서 컴파일도 일어남

배포: 빌드한 결과물을 사용자에게 전달하는 과정, 업로드하거나, 플레이스토어에 올리거나, 도메인에서 볼 수 있게 등등.. 웹사이트 배포가 제일 많음

환경변수: 환경은 소프트웨어가 동작하는 공간, 변수는 그 파일 위치를 표현하기 위해, 그리고 보안요소임

라이브러리: 누군가 잘 짜놓은 코드를 가져다 쓰는 것, 당연 내 코드일 수도 있음,

프레임워크: 어떤것 위에서함





Process

**동시성**: 프로세서 하나가 이거 조금 저거 조금 하는 작업, 이렇게 바꾸는 작업을 Context Switching이라 한다.

**병렬성**: 프로세서 하나에 코어 여러개가 달려서 각각 동시에 작업들을 수행함, 멀티 코어에서 가능한 일.



컴퓨터는 프로세스마다 자원을 분할해서 할당 그 프로세스 안에서도 여러 스레드가 있는 것,
 같은 자원을 공유함 스레드는, 단점은 스레드가 같은 자원을 작업할때 error, 그래서 자바같은 코드를 보면 
동시에 손댈 수 없게 `synchronzied`라는 함수를 사용하여 방지



HTTPS(secure)

내가 어디에 보내는 코드를 누가 훔쳐보지 못하게 보안함. s가 붙으면 중간에 누가 못보고 해당사이트만 볼 수 있음. 기관으로 검증된 사이트만 s가 붙을 수 있어서 피싱사이트 방지를 해줌.



대칭키와 비대칭키

대칭 키: 메시지를 보내는쪽과 받는 쪽이 똑같은 키를 가지고 있어서 그 키로 암호화 복호화함. 그래서 이 키만 노출되지 않으면 암호문을 해독할 수 없음, 근데 애초에 어케 공유해? 처음엔 보내야하는데,, 이게 한계

비대칭 키: 키가 2개임 서로 다르기 때문에 비대칭 키 각각은 서로 다른 키로 된 암호만 읽을 수 있다. 그래서 공개키를 사람들한테 뿌리고 비공개키는 자신만 가지고 있다. 개인키만 가지고 있는 사람만 읽을 수 있다.

네이버가 우리에게 보내는정보가 그 일부가 네이버의 개인키의 일부로 되어있음. 중간에서 그게 네이버의 키가 맞다. 라고하면 검증할 수 있다.



공개키는 정품임?  -> CA회사가 (크롬, 사파리, 엣지 등에는 CA의 목록이 저장되어 있음)

비대칭 키는 부담이 돼서 결국 대칭키를 사용하는데, 초반에 무작위데이터를 주고받아서 결국 다시 공개키를 만든다. 비대칭키로 대칭키를 만들어서 사용하는 것이다.


데이터베이스 특징
독립성
무결성
보안성
일관성
중복최소화

성능 이슈는 I/O문제에서 나오는데 순차 I/O가 랜덤 I/O보다 빠르다.
쿼리 튜닝은 랜덤 I/O를 순차 I/O로 바꾸는 작업

정규화와 반정규화

트랜잭션의 특성 ACID
원자성: 제대로 실행되거나 아예 안되거나
일관성: 트랜잭션이 완료된 다음의 상태에서도 일어나기 전의 상황과 동일하게 데이터의 상태가 정상상태
고립성: 각각의 트랜잭션은 간섭이 없음
지속성: 트랜잭션이 종료된 다음 디비에 작업결과가 저장되어야 함

트랜잭션은 꼭 최소의 코드에 적용해야 커넥션이 마르지 않는다.
교착상태 ( 데드락이란? )
이를 해결하기 위해서는?
트랜잭션을 자주 커밋, 정해진 순서로 테이블에 접근 테이블 방향이 꼬이지 않게
읽기 잠금의 사용을 피함

멀티태스킹
멀티스레드
멀티프로세싱

race condition
동기화
크리티컬섹션, 하나의 프로세스 스레드만 진입하는걸 mutual exclusion이라함
그리고 이 뮤츄얼 익스클루젼을 보장하는것은 락을 사용한다.

락을 주는 함수, TestAndSet은 CPU의 atomic 명령어다.
실행중간에 간섭받거나 중단되지 않으며,
같은 메모리 영역에 대해 동시에 실행되지 않는다.
cpu의 도움을 받아서 진행되는거다.

락을 계속확인하는 이방식은 계속돌고돌면서 확인해서 스핀락이라 한다.
그리고 기다리는동안 계속 확인해야ㅏ니 cpu	낭비가 있다.
그래서 락이 준비되면 나깨워줘.... mutex로 락이 없으면 go to sleep, 
mutex에서 value와 guard가 있는데 value값을 통해 하나만 실행시킴
value도 공유되는 데이터이므로 보호받아야하므로 guard를 취득한사람만
value를 에 도전할 기회를 얻음 value에 도전한 사람은 잠잘지 실행할지..
뮤텍스가 끝날때 큐에 하나라도 있으면 꺠움, 그리고 guard는 아토믹함수를 쓰고있다.

mutex가 스핀락보다 한창좋을까? 
멀티코어환경에 크리티컬섹션에서의 작업이 컨텍스트스위칭보다 더 빨리 끝난다면
스핀락이 뮤텍스보다 더 좋다

세마포: 싱글 메커니즘을 가진 하나이상의 프로세스/스레드가 크리티컬섹션에
접근가능하게함, value값을 1과 0이 아니라, 0이상의 값..초기 밸류값에 따라..
여러개쓰면 카운팅세마포
순서를 정해줄때도 세마포를 사용할 수 있음 그래서 시그널 메커니즘을 가짐

뮤텍스와 이진세마포는 다르다.
왜? 뮤텍스는 락을 가진자만 락을 해제 가능,
이진세마포는 다르다.
뮤텍스는 priority inheritance 속성을 가짐 누구먼저 수행할지 스케줄링하는데
우선순위가 낮은 프로세스가 진행중에 우선순위가 높은 프로세스가 락에 밀려있다해보자
그럼 이 프로세스는 천천히 수행될텐데, 스케줄러가 이를보고 우선순위를 높여버린다. 그러면
빨리 끝내고 나와서 우선순위가 높은 프로세스를 이어하는것이다.
세마포는 누가 락을 해제할지 몰라서 이를 사용할 수 없다.

모니터: mutual exclusion을 보장
모니터의 구성요소 mutex, condition variable(waiting queue)
컨디션베리어블의 주요동작: wait (대기상태로 전환) signal (대기중인놈 깨움) broad cast(전부꺠움)
두개의 큐가있다.
엔트리 큐(뮤텍스 큐), 웨이팅 큐(컨이션베리어블의 큐)

자바에서 모니터란? 모든 객체가 내부적으로 모니터를 가지고있다.
모니터의 mutual exclusion은 synchronized 키워드로 사용한다.
자바의 모니터는 컨디션 베리어블을 하나를 가진다.
wait notify notifyall

멀티스레드의 동시접근에 관해서,,
CPU레지스터에 올라가서 반환하기전 다른 스레드가 접근하면?
이를 해결하기위한 크리티컬섹션.. 조건은?
뮤츄얼 익스클루젼: 한번에 하나만 실행가능
PROGRESS: 크리티컬 섹션이 비어있고 들어가길 원한다면 그중하나는 실행될 수 있게, 진행될수있게
BOUNDED WAITING: 어떤 프로세스가 무한정 기다리면안됨.
그래야 해결책이 될 수 있다.

블락 IO와 넌블락 IO
I/O의 종류
network(socket)
네트워크 통신은 socket을 통해 데이터가 입출력된다. 요청자와 응답자는 각각 소켓을 열고 
통신을 한다. 1:1로 각각의 소켓끼리 통신한다.
블락 IO: IO작업을 요청한 프로세스, 스레드는 요청이 완료될때까지 블락됨, 아무것도못함

소켓에는 버퍼가 보내는버퍼, 받는 버퍼가 있음 한쪽이 데이터를 보내면 받는쪽은 일단 기다려야함
내가 소켓의 리드를 호출(리시브 버퍼를 살펴봄)했는데 데이터가 없으면 해당 프로세스나 ㅍ스레드는 기다려야함
리시브가 들어올때까지....
보내는 쪽은 WRITE를 하게되면 보내는 버퍼가 가득차서 데이터를 쓸 수 없으면 블락됨
공간이 생길때까지 블락이 되는거임

넌블락 IO는 블락시키지 않고 진행
소켓에서 리드를 했을때 데이터가없다면 데이터가 없다면 그냥 그거 종료하고 이어서함
읽을때도 공간이 가득차도 다시반환
근데 그럼 I/O작업 완료를 어떻게 확인하는가
결과처리방식:
1. 완료됐는지 반복적으로 확인, 완료된 시간과 확인 시간사이의 갭으로 처리속도 감소될 수 있음
  확인 자체가 CPU낭비임, 서버는 소켓이 개많을테니 계속 데이터확인자체가 낭비임
  블라킹으로하면 다른 소켓에 처리를 못해줌 다른 클라이언트는 불만이됨
  그래서 서버는 넌블라킹을 써야함
2. 다중입출력(I/O multiplexing) 관심있는 I/O작업들을 동시에 모니터링하고 완료된 I/O작업들을
  한번아 알려줌,
  epoll리눅스, kqueue맥, iocp윈
  네트워크 통신에 많이 사용함, 톰캣이나 이런게 I/O멀티플렉싱이 해줌 => 중요함

3. 콜백이나 시그널, 콜백이나 시그널을 통해.. (널리안씀)

컨텍스트스위칭에서 왜 스레드가 더빠를까?