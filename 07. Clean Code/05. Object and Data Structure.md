# Object and Data Structure



변수를 private로 정의하는 이유가 있다. 남들이 변수에 의존하지 않게 만들고 싶어서다. 그렇다면 어째서 수많은 프로그래머가 조회함수와 설정함수를 당연하게 공개해 비공개 변수를 외부에 노출할까?



##### 자료 추상화

두가지 코드를 보자.

```java
public class Point{
  public double x;
  public double y;
}
```



```java
public interface Point{
  double getX();
  double getY();
  void setCartesian(double x, double y);
  double getR();
  double getTheta();
  void setPolar(double r, double theta);
}
```

아래 코드는 점이 직교좌표계인지 극좌표계인지 모른다. 물론 둘다 아닐수도 있다.

위의 코드는 확실히 직교좌표계를 사용하며, 개별적으로 좌표값을 읽고 설정하게강제한다. 또한 구현을 노출한다. 변수를 private로 선언하더라도, 각 값마다 조회함수와 설정함수를 제공한다면 구현을 외부로 노출하는 셈이다. 변수 사이에 함수라는 계층을 넣는다고 구현이 저절로 감춰지지는 않는다. 구현을 감추려면 추상화가 필요하다! 그저 형식논리에 치우쳐 <u>조회함수와 설정함수로 변수를 다룬다고 클래스가 되지 않는다.</u> 그보다는 추상 인터페이스를 제공해, 사용자가 구현을 모른 채 자료의 핵심을 조작할 수 있어야 진정한 의미의 클래스다.

다음 두개의 코드를 보자.

구체적인 클래스

```java
public interface Vehicle {
  double getFuelTankCapacityInGallons();
  double getGallonsOfGasoline();
}
```

추상적인 클래스

```java
public interface Vehicle {
  double getPercentFuelRemaining();
}
```

구체적인 것은 연료 상태를 구체적인 숫자 값으로 알려준다. 그리고 두 함수가 변수값을 읽어 반환할 뿐이라는 사실이 거의 확실하다. 하지만 추상적인 클래스는 정보가 어디서 오는지 전혀 드러나지 않는다.

이처럼 자료를 세세하게 공개하기보다는 추상적인 개념으로 표현하는 편이 좋다. 개발자는 객체가 포함하는 자료를 표현할 가장 좋은 방법을 심각하게 고민해야 한다. <u>아무 생각 없이 조회/설정 함수를 추가하는 방법</u>이 가장 나쁘다.



##### 자료/객체 비대칭

위의 예제는 객체와 자료 구조 사이에 벌어진 차이를 보여준다. 객체는 추상화 뒤로 자료를 숨긴 채 자료를 다루는 함수만 공개한다. 자료구조는 자료를 그대로 공개하며 별다른 함수를 제공하지는 않는다.

절차적인 도형클래스와 객체 지향적인 도형 클래스는 완전하게 상반된다.

절차적인 도형클래스를 만든다면, 도형클래스는 간단한 자료구조일 뿐 아무 메서드도 제공하지 않고, 동작방식은 새로운 클래스에서 제공할 것이다. 만약 동작을 제공해주는 클래스가 넓이만을 제공했다고 하자. 여기서 둘레의 길이를 구하는 함수를 추가한다면? 도형 클래스는 아무 영향도 받지 않는다. 하지만 새 도형을 추가하고 싶다면? 그럼 클래스에서 제공하던 함수를 모조리 바꿔야 한다.

객체지향적인 도형 클래스를 만든다면, 동작을 제공해주는 클래스는 필요 없다. 그러므로 새 도형을 추가해도 기존 함수에 아무런 영향을 끼치지 않는다. 하지만 둘레의 길이를 구하고 싶다고 추가한다면? 모든 도형에 추가해야 한다.

결론적으로 말하면,  절차적인 코드는 기존 자료구조를 변경하지 않으면서 새 함수를 추가하기 쉽고, 새로운 자료 구조를 추가하기는 어렵다. 객체지향적인 코드는 새로운 자료구조를 추가하기 쉽지만, 새로운 함수를 추가하기는 어렵다.

따라서 복잡한 시스템을 짜면 어느 것이 맞는지에 대해 좀 고민해볼 필요가 있다. 분별 있는 프로그래머는 모든 것이 객체라는 생각이 <u>미신</u>임을 잘 안다. 때로는 단순한 자료 구조와 절차적인 코드가 적합한 상황도 있다.



##### 디미터 법칙

잘알려진 휴리스틱으로, 모듈은 자신이 조작하는 객체의 속사정을 몰라야 한다는 법칙이다. 앞에서 봤듯, 객체는 자료를 숨기고 함수를 공개해야 한다. 즉, 조회 함수로 내부 구조를 공개하면 안된다는 의미다. 그러면 내부 구조를 숨기지 않고 노출하는 셈이다.

다음 코드는 디미터 법칙을 어기는 듯 보인다.

```java
final String outputDir = ctxt.getOptions().getScratchDir().getAbsolutePath();
```

흔히 이런 코드를 기차 충돌이라 부른다. 여러 객차가 한줄로 이어진 기차처럼 보이기 때문이다. 일반적으로 **조잡하다.** 여겨지는 방식이므로 피하는 편이 좋다.

