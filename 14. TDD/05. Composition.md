# Composition



기능은 주어진 상황에 따라 다르게 동작한다. 예를 들어 다음 기능을 보자.

- 파일에서 숫자를 읽어와 숫자의 합을 구한다.
- 한 줄마다 한 개의 숫자를 포함한다.

이 기능을 MathUnit.sum() 메서드로 구현한다고 가정하자. 다음처럼 구현할 수 있을 것 같다.

```java
File dataFile = new Filew("data.txt");
long sum = MathUtils.sum(dateFile);
```

하지만 이 기능을 구현하려면 고려할 것이 있다. 먼저 파이링 없는 상황을 처리해야 한다. 비슷하게 데이터 중 숫자가 아닌 잘못된 데이터가 존재하는 경우에도 알맞은 결과를 생성해야 한다.

개발자는 결과에 영향을 줄 수 있는 상황을 염두에 두어야 한다. 이를 고려하지 않으면 버그를 포함할 가능성이 크기 때문이다. 이를 코드에 반영해야 기능이 비정상적으로 동작하는 것을 막을 수 있다.



#### 테스트 코드의 구성요소

테스트 코드의 구성요소는 세 가지로 구성된다.

- 상황
- 실행
- 결과확인

어떤 상황이 주어지고 그 상황에서 기능을 실행하고, 실행한 결과를 확인하는 세 가지가 테스트 코드의 기본 골격을 이루게 된다. 

JUnit에서 상황을 설정하는 방법은 테스트할 대상에 따라 달라진다. 숫자 야구 게임을 예로 들어보자. 숫자 야구 게임을 구현한 BaseballGame 클래스는 객체를 생성할 때 정답 숫자를 지정한다. 이 경우 각 테스트마다 객체를 생성해서 상황을 설정할 수 있다. 혹은 @BeforeEach를 적용한 메서드에서 상황을 설정할 수도 있다.

상황 설정이 테스트 대상으로 국한된 것은 아니다 상황에는 외부 요인도 있다. 위에서 예로 들은 sum 메서드의 코드에서 이를 테스트 하려면 파일이 존재하지 않는 상황에서의 결과도 확인해야 한다. 이런 상황을 테스트하는 가장 쉬운 방법은 존재하지 않는 파일을 경로로 사용하는 것이다.

이 방법이 쉽긴하지만 우연이라도 해당 파일이 존재할 수 있다. 우연에 의해 테스트 결과가 달라지면 좋지 않다. 따라서 더욱 명시적으로 파일이 없는 상황을 만드는 것이 좋다. 다음처럼 가능하다.

```java
@Test
void noDataFile_Then_Exception() {
  givenNoFile("badpath.txt");
  
  File dataFile = new File("badpath.txt");
  assertThrows(IllegalArgumentException.class,
              () -> MathUtils.sum(dataFile)
              );
}

private void givenNoFile(String path) {
  File file = new File(path);
  if(file.exists()){
    boolean deleted = file.delete();
    if (!deleted)
      throw new RuntimeException("fail givenNoFile: " +path);
  }
}
```

이 테스트에서 해당 경로에 파일이 있는지 검사해서 존재할 경우 파일을 삭제한다. 이렇게 보장한다. 물론 파일이 존재하는 상황역시 테스트를 해야한다. 해당 경로에 미리 파일을 만들면 된다.



#### 외부 상태가 테스트 결과에 영향을 주지 않게 하기

테스트 코드는 한 번만 실행하고 끝나지 않는다. TDD를 진행하는 동안에도 계속 실행하고 개발이 끝난 이후에도 반복적으로 테스트를 실행해서 문제가 없는지 검증한다. 그렇기 때문에 테스트는 언제 실행해도 항상 정장적으로 동작하는 것이 중요하다. 간헐적으로 실패하거나 다른 테스트 다음에 실행해야 성공하면 결과를 믿을 수 없게 된다. 이렇게 되면 테스트가 실패해도 무감각해지고 더 나아가 테스트를 만들지 않게 된다.

회원 가입 기능을 예로 들어보자. 이 기능테스트에 다음이 포함된다.

- 중복된 ID가 이미 존재하면 가입 실패
- 모든 조건을 충족하면 가입 성공

이 테스트 코드를 짤 때 테스트에 성공했다고 아이디를 만들고 방치하면 안된다. 그럼 같은 코드를 실행하는 데 다음에는 중복이라고 실패할 수도 있다. DB 데이터의 상태에 따라 테스트가 성공하기도 하고 실패하기도 한다. 따라서 외부 상태에 따라 바뀌지 않으려면 테스트 실행 전에 외부를 원하는 상태로 만들거나 실행 후 외부 상태를 원래대로 되돌려 놓아야 한다. 트랜잭션을 롤백하는 방법을 꼭 생각해야 한다.



#### 외부 상태와 테스트 어려움

상황과 결과에 영향을 주는 외부 요인은 파일, DBMS, 외부 서버 등 다양하다. 외들 외부 환경을 테스트에 맞게 구성하는 것이 항상 가능한 것은 아니다. 자동이체 등록 기능을 생각해보자. 이 기능은 입력받은 계좌번호가 올바른지 확인해야 한다. 이를 위해 금융 회사에서 제공하는 REST API를 사용한다면 자동이체 등록 기능에 대한 테스트는 다음 상황에서의 결과를 확인할 수 있어야 한다.

- REST API 응답 결과가 유효한 계좌 번호인 상황
- REST API 응답 결과가 유효하지 않은 계좌 번호인 상황
- REST API 서버에 연결할 수 없는 상황
- REST API 서버에서 응답을 5초 이내에 받지 못하는 상황

이런 경우 위 2개는 해결할 수 있어도 아래 2개는 해결하기가 힘들다. "잠깐 서버좀 꺼주세요." 할 수도 없다. 그리고 DB의 경우 DELETE 권한을 주지 않을 수도 있다.(중요하기에) 따라서 외부 요인은 다루기 힘들다. 이럴 경우 대역을 사용하면 테스트 작성이 쉬워진다. 대역엔 다양한 종류가 있다.