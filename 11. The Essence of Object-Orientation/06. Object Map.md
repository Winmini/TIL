# Object Map



길을 모를 때, 찾아가는 방법은 사람에게 묻는 방법과 지도를 펴서 찾아가는 방법이 있다. 둘 다 어찌됐든 도착이야 하겠지만, 재사용성과 안정성 측면에서는 지도가 좋다. 지도는 옛날 지도라 하더라도 구조를 기반으로 하였기에 지금도 어느정도 사용할 수 있다.

안정적인 구조를 중심으로 기능을 종속시키는 접근법은 범용적이고 재사용 가능하며 변경에 유연하게 대처할 수 있다. 전통적인 소프트웨어 개발 방법은 길을 묻는 방법과 비슷하며 객체지향 개발 방법은 지도의 방법과 비슷하다.



#### 기능 설계와 구조 설계

기능 측면의 설계는 제품이 사용자를 위해 무엇을 할 수 있는지에 초점을 맞추고, 구조 측면의 설계는 제품의 형태가 어떠해야 하는지에 초점을 맞춘다. 설계의 가장 큰 도전은 기능과 구조라는 두 가지 측면을 함께 녹여 조화를 이루도록 하는 것이다.

소프트웨어가 사용자에게 가치있는 이유는 사용자가 필요로 하는 기능을 제공하기 때문이다. 이 기능은 사용자가 금전적인 대가를 지불하고서라도 구매할 수 있을 정도로 매력적이어야 한다. 그래서 소프트웨어 개발 초기에는 사용자가 무엇을 원하는지 어떤 기능을 제공해야 하는지에 초점을 맞췄다.

요구사항이 변경되지 않는다면 어떻게 했던지 문제가 없다. 다시 코드를 볼 일이 없을테니 말이다. 하지만 불행하게도 요구사항은 변경된다. 소프트웨어 분야에서 예외가 없는 유일한 규칙은 요구사항이 항상 변경된다는 것이다.

때문에 좋은 설계에 대한 압력 역시 피할 수 없다. 예측 불가능하게 변경되기 때문에 훌륭한 기능을 제공하는 동시에 예측 불가능한 요구사항 변경에 유연하게 대처할 수 있는 안정적인 구조를 제공하는 능력도 갖춰야 한다. 미래에 대비하는 좋은 방법은 변경을 예측하는 것이 아니라 변경을 수용할 수 있는 선택의 여지를 설계에 마련해 놓는 것이다.



#### 안정적인 재료: 구조

은행에서는 고객의 소중한 자산을 관리하고 보호하기 위해 소프트웨어를 사용한다. 무료한 시간을 달래기 위해 사람들은 게임 소프트웨어에 열중한다. 소프트웨어를 사용하는 사람들은 자신이 관심을 가지고 있는 특정한 분야의 문제를 해결하기 위해 소프트웨어를 사용한다. 이처럼 사용자가 프로그램을 사용하는 대상 분야를 <u>도메인</u>이라고 한다.

도메인 모델에서 <u>모델</u>이란 대상을 추상화하고 단순화해서 표현한 것이다. 그리고 그 밖의 관련 없는 세부 사항에 대해서는 무시할 수 있다. 모델은 복잡성을 관리하기 위해 사용하는 기본적인 도구다.

따라서 <u>도메인 모델이란</u> 사용자가 프로그램을 사용하는 대상 영역에 관한 지식을 선택적으로 단순화하고 의식적으로 구조화한 형태다. 소프트웨어가 목적하는 영역 내의 개념과 개념 간의 관계, 다양한 규칙이나 제약 등을 주의 깊게 추상화한 것이다.

이러한 도메인 모델은 멘탈 모델과 연관이 있다. 사용자들이 제품에 대해 가지고 있는 멘탈 모델과 제품 설계와 일치해야 한다. 사용자들은 자신의 멘탈 모델과 유사한 방식으로 제품이 반응하고 움질일 것이라고 기대하기 때문에 이에 적합하게 제품을 만들어야 한다. 동일하다면 이상적이지만 사용자와 설계자는 직접적으로 상호작용할 수 없으며 단지 최종 제품인 시스템 그 자체를 통해서만 의사소통할 수 있다. 따라서 설계자는 디자인 모델을 기반으로 만든 시스템 이미지가 사용자 모델을 정확하게 반영하도록 노력해야 한다.

도메인 모델을 기반으로 코드를 작성하는 이유는 도메인 모델이 제공하는 구조가 상대적으로 안정적이다. 도메인에 대한 사용자의 관점을 반영해야 하는 이유는 사용자들이 누구보다도 도메인의 '본질적인' 측면을 가장 잘 이해하고 있기 때문이다. 사용자들은 도메인을 구성하는 중요한 개념과 개념 간의 관계를 가장 잘 알고 있는 사람들이다. 사용자 모델에 포함된 개념과 규칙은 비교적 변경될 확률이 적기 때문에 사용자 모델을 기반으로 설계와 코드를 만들면 변경에 쉽게 대처할 수 있을 가능성이 커진다.

따라서 도메인 모델은 우리가 기능을 구현할 때 참조할 수 있는 궁극적인 지도와 같다.



#### 불안정한 재료: 기능

비록 도메인 모델이 도메인과 관련된 중요한 개념과 관계를 보여준다고 해도 실제로 사용자에게 중요한 것은 도메인 모델이 아니라 소프트웨어의 기능이다. 소프트웨어의 존재 이유는 사용자가 원하는 목표를 달성할 수 있는 다양한 기능을 제공하는 것이다. 객체지향 커뮤니티에서는 오래 전부터 소프트웨어의 기능을 기술하기 위해 <u>유스케이스</u>라는 유용한 기법을 사용해왔다.

##### 유스케이스

기능적 요구사항이란 시스템이 사용자에게 제공해야 하는 기능의 목록을 정리한 것이다. 그리고 제공하는 이유는 사용자가 시스템을 통해 달성하고자 하는 '목표'가 존재하기 때문이다. 따라서 훌륭한 기능적 요구사항을 얻기 위해서는 시스템과 사용자간의 상호작용 관점에서 바라봐야 한다.

사용자는 자신의 목표를 달성하기 위해 시스템과의 상호작용을 시작한다. 사용자가 시스템에게 작업을 요청하면 시스템은 요청을 처리한 후 사용자에게 원하는 결과를 제공한다. 그리고 그 응답을 기반으로 다른 작업을 요청하고 받고 진행된다. 목표를 만족시키거나, 에러등의 이유로 상호작용을 더 이상 진행할 수 없을 때까지 계속된다.

이런 상호작용의 흐름을 텍스트로 정리한 것을 유스케이스라고 한다.

먼저 유스케이스의 예시와 그로 특성을 알아보자.

```
유스케이스명: 중도 해지 이자액을 계산한다.

일차 액터: 예금주

주요 성공 시나리오:
1. 예금주가 정기예금 계좌를 선택한다.
2. 시스템은 정기예금 계좌 정보를 보여준다.
3. 예금주가 금일 기준으로 예금을 해지할 경우 지급받을 수 있는 이자 계산을 요청한다.
4. 시스템은 중도 해지 시 지급받을 수 있는 이자를 계산한 후 결과르르 사용자에게 제공한다.

확장:
3a. 사용자는 해지 일자를 다른 일자로 입력할 수 있다.
```



유스케이스의 특성은 크게 5가지가 있다.

- 유스케이스는 사용자와 시스템 간의 상호작용을 보여주는 '텍스트'다. 다이어그램이 아니다. 유스케이스 안에 포함돼 있는 상호작용의 흐름이다.
- 하나의 시나리오가 아니라 여러 시나리오들의 집합이다. 시나리오는 유스케이스를 통해 시스템을 사용하는 하나의 특정한 이야기 또는 경로다. 이자 계산 유스케이스는 2개의 시나리오를 포함하고 있다. 하나는 예금주가 계좌를 선택하고 당일까지의 이자액을 계산하는 것이다. 다른 하나는 예금주가 계좌를 선택하고 특정 일자까지의 이자액을 계산하는 것이다. 참고로 시나리오를 <u>유스케이스 인스턴스</u>라고도 한다.  
- 유스케이스는 단순한 피처 목록과 다르다. 피처는 기능의 목록을 단순하게 나열한 것이고, 피처는 서로 연관이 없는 독립적인 기능으로 보이게끔 만드는 단점도 있다. 유스케이스는 단순한 기능을 나열하는 것이 아니라 이야기를 통해 연관된 기능들을 함께 묶을 수 있다는 점이다.
- 사용자 인터페이스와 관련된 세부 정보를 포함하지 말아야 한다. 위 유스케이스에는 사용자가 해지 일자를 선택하기 위해 사용자 인터페이스를 어떻게 구성해야 하는지에 대한 정보가 전혀 포함돼 있지 않다. 자주 변경되는 인터페이스 요소는 배제하고 사용자 관점에서 행위에 초점을 맞춘다.
- 내부 설계와 관련된 정보를 포함하지 않는다. 유스케이스의 목적은 연관된 시스템의 기능을 이야기 형식으로 모으는 것이지 내부 설계를 설명하는 것이 아니다. 단지 시스템을 통해 무엇을 얻을 수 있고, 어떻게 상호작용할 수 있느냐에 관한 정보만 기술된다.

유스케이스는 객체지향과도 상관이 없다. 그리고 유스케이스로부터 내부 구조를 유추할 수 있는 방법은 존재하지 않는다. 객체지향은 유스케이스 이외의 방법으로 요구사항을 명시할 수도 있다. 단지 기능적 요구사항을 사용자의 목표라는 문맥을 중심으로 묶기 위한 정리 기법일 뿐이다.