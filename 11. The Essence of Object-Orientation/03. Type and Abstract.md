# Type and Abstract



지하철 노선도는 원래 실제와 유사한 물리적인 지형 위에 구불구불한 운행 노선과 불규칙적인 역 간의 거리를 사실적으로 묘사했었다. 문제는 이렇게 지나친 사실 정보가 노선도를 이해하기 어렵게 만들었다.

지하철을 이용하승객의 목적은 하나의 역에서 다른 역으로 이동하는 것이고, 결국 원하는 것은 어떤 역에서 출발해야 하는지와 어떤 역에서 환승해야 하는지 그리고 어떤 역을 거쳐야 가장 쉽고 빠르게 목적지에 도착할 수 있는지를 직관적이고 단순하게 보여주는 것이다.

지하철 노선도 디자인에서 중요한 것은 얼마나 사실적으로 지형을 묘사했느냐가 아니라 역과 역사이의 연결성을 얼마나 직관적으로 표현했느냐다. 1933년 해리 벡이 사실적인 지형과 축척은 무시하고 연결성만 집중한 혁신적인 노선도를 창조했다. 역의 순서를 갈아타는 역의 표시를 제외하면 어느 것 하나 정확한 것이 없지만 70년이 지난 현재까지도 커다란 수정 없이 전 세계 지하철 노선도에 적용되고 있다. 헤리 벡의 가장 위대한 업적은 지하철 노선을 추상화한 것이다.



#### 추상화를 통한 복잡성 극복

현실은 복잡하며 예측 불가능하다. 주식이 어떻게 될지, 다음 주 날씨, ~~내 여자친구과 화난 이유~~ 등 은 도저히 알 수가 없다.

현실에 존재하는 다양한 현상을 이해하기 위해선 우선 현실을 이해해야 한다. 복잡한 총체 자체를 이해하기엔 인간이 지닌 인지 능력과 저장 공간이 보잘 것 없는 것이 가장 큰 문제이다. 이를 해결하기 위해 본능적으로 이해하기 쉽고 예측 가능한 수준으로 현실을 분해하고 단순화하는 전략을 따르게 된다.

헤리 백의 지하처러 노선도처럼 추상화란 현실에서 출발하되 불필요한 부분(노선도에서 지형)을 도려가며 사물의 놀라운 본질(역과 역 사이의 연결 관계)을 드러나게 하는 과정이라고 할 수 있다. 또한 노선도를 통해 알 수 있는 것처럼 훌륭한 추상화는 목적에 부합하는 것이어야 한다. 사실적인 지형 정보를 추가한 초기 노선도도 훌륭한 추상화지만 목적에는 부합하지 않았다.

어떤 추상화도 의도된 목적이 아닌 다른 목적으로 사용된다면 오도될 수 있다. 추상화의 수준, 이익, 가치는 목적에 의존적이다. 저자는 추상화를 다음과 같이 정의한다.



#### '추상화'

: 어떤 양상, 세부 사항, 구조를 좀 더 명확하게 이해하기 위해 특정 절차나 물체를 의도적으로 생략하거나 감춤으로써 복잡도를 극복하는 방법이다.  복잡성을 다루기 위해 추상화는 두 차원에서 이뤄진다.

- 첫 번째 차원은 구체적인 사물들 간의 공통점을 취하고 차이점은 버리는 일반화를 통해 단순하게 만드는 것이다.
- 두 번째 차원은 중요한 부분을 강조하기 위해 불필요한 세부 사항을 제거함으로써 단순하게 만드는 것이다.

모든 경우에 추상화의 목적은 복잡성을 이해하기 쉬운 수준으로 단순화하는 것이라는 점을 기억해라.



#### 객체지향과 추상화

우리는 주변에 존재하는 다양한 사물들에게 특정한 개념을 적용하는 데 익숙하다. 공통점을 기반으로 객체들을 묶기 위한 그릇을 **개념(concept)**이라고 한다. 길거리를 빠른 속도로 누비는 교통수단에 대해서는 '자동차'라는 개념을 적용한다. 하늘을 나는 교통수단을 지칭하는 개념은 '비행기'다. 자동차의 종류와 특징은 천차만별이지만, 자동차라는 개념으로 묶음으로써 여러 '자동차'들을 개별적으로 다뤄야 하는 복잡한 상황을 피할 수 있다.

개념을 이용하면 객체를 여러 그룹으로 **분류(classification)**할 수 있다. 자동차와 비행기 이렇게 두 개의 개념으로 나누고 분류할 수 있다. 결과적으로 개념은 공통점을 기반으로 객체를 분류할 수 있는 일종의 체라고 할 수 있다.

결국 각 객체는 특정한 개념을 표현하는 그룹의 일원으로 포함된다. 람보르기니는 자동차라는 개념 그룹의 일원이고 보잉747은 비행기라는 개념 그룹의 일원이다. 이처럼 객체에 어떤 개념을 적용하는 것이 가능해서 개념 그룹의 일원이 될 때 객체를 그 개념의 **인스턴스(instance)**라고 한다.

##### "객체란 특정한 개념을 적용할 수 있는 구체적인 사물을 의미한다. 개념이 객체에 적용됐을 때 객체를 그 개념의 인스턴스라고 한다"



#### 개념의 세 가지 관점

개념은 특정한 객체가 어떤 그룹에 속할 것인지를 결정한다. 제네시스가 '자동차'란느 개념으로 불릴 수 있는 이유는 우리가 '자동차'라고 부를 때 머릿속에서 떠오르는 일반적인 의미를 제네시스가 만족시키기 때문이다. 일반적으로 객체의 분류 장치로서 개념을 이야기할 때는 아래의 세 가지 관점을 함께 언급한다.

- 심볼(symbol): 개념을 가리키는 간략한 이름이나 명칭
- 내연(intension): 개념의 완전한 정의를 나타내며 내연의 의미를 이용해 객체가 개념에 속하는지 여부를 확인할 수 있다.
- 외연(extension): 개념에 속하는 모든 객체의 집합(set)

뭔가 어려워 보이지만 이미 모두 이야기한 내용이다. 먼저 심볼이란 개념을 가리키는 이름이다. '자동차'라는 이름은 개념의 심볼이 된다.

내연이란 개념의 의미를 나타낸다. 바퀴가 보통 4개가 달렸고, 운전좌석이 있으며, 기름, 전기를 이용하여 편리하게 지상을 이동하는 교통 수단이라는 자동차에 대한 설명이 바로 내연이다. 내연이란 개념을 객체에 적용할 수 있는지 여부를 판단하기 위한 조건이다. 보잉747은 날개가 달렸고, 하늘을 이동하는 교통수단이라는 점에서 자동차가 될 수 없다.

마지막으로 외연은 개념에 속하는 객체들, 제네시스, 람보르기니, 부가티 등 개념의 인스턴스들이 모여 이뤄진 집합을 가리킨다.

개념을 구성하는 심볼, 내연, 외연은 객체의 분류 방식에 대한 지침을 제공한다. 하지만 이러한 것으로 구성되어있다는 사실보다는 개념을 이용해 객체를 분류할 수 있다는 사실이 당연히 더 중요하다. 이 아이디어는 객체지향 패러다임이 복잡성을 극복하는 데 사용하는 가장 기본적인 인지 수단이기 때문이다.

객체지향의 세계에서 가장 널리 알려진 유명인사가 클래스(class)라는 사실을 감안한다면 분류(classification)라는 개념이 얼마나 중요한지 실감할 수 있을 것이다.



#### 객체를 분류하기 위한 틀

분류란 특정한 객체를 특정한 개념의 객체 집합에 포함시키거나 포함시키지 않는 작업이다. 분류는 객체지향의 가장 중요한 개념 중 하나다. 어떤 객체를 어떤 개념으로 분류할지가 객체지향의 품질을 결정한다. 객체제 적절한 개념에 따라 분류하지 못한 애플리케이션은 유지보수가 어렵고 변화에 쉽게 대처하지 못한다.

객체는 소중하며, 소중한 객체를 안전하고 적절한 장소에 보관할 수 있도록 최대한 직관적으로 분류하길 바란다.



#### 타입

사실 타입은 개념이다. 개념이라는 단어 자체는 폭넓게 사용되는 단어지만 컴퓨터 공학자는 좀 더 멋지게 표현할만한 자신들의 용어를 가지고 싶었던 것 같다. 그게 바로 **타입(type)**이다.

타입의 정의는 개념의 정의와 완전히 동일하다. 하지만 안타깝게도 타입이 근본적으로 개념과 동이랗다 하더라도 컴퓨터 내부로 들어오는 순간 좀 더 기계적인 의미로 윤색될 수 밖에 없다.



##### 데이터 타입

컴퓨터가 어떤 작업을 수행하기 위해서 작업에 필요한 데이터를 메모리 안으로 불러들여야 한다. 메모리에 불러들여진 데이터들은 무수히 많은 0과 1로 치장되어 메모리에 저장된다. 실제로 메모리엔 끝없이 펼쳐진 0과 1의 행렬만이 존재한다. 그리고 타입이라는 질서는 당연히 존재하지 않는다. 타입이 없는 체게 안에서 모든 데이터는 일련의 **비트열(bit string)**로 구성된다. 이 비트열을 직접 들여다 보면서 어떤 의미인지 말할 수 있는 사람은 아무도 없다. 그 값의 의미는 그 값을 가져다 자신의 용도에 맞게 사용하는 외부의 해석가에 의해 결정된다. 흔히 우리가 애플리케이션이라고 부르는 프로그램이 바로 그런 해석가의 일종이다.

애플리케이션 안에서 타입이 없는 메모리 내부의 값을 다루면 수많은 오해와 시행착오가 생긴다. 메모리 안에 저장된 '10010001'이라는 값은 숫자인가, 문자인가, 특정한 메모리 상의 주소인가, 라는 혼란을 낳으며 그 혼란은 점차 가중되다 데이터를 잘못 사용하여 애플이케이션이 죽어버린다.

이런 무질서를 해겨랗기 위해 데이터에 특정한 의미를 부여하기 시작했다. 숫자, 논리, 등 이런 목적에 따라 분류하면서 타입 시스템(type system)이 자랐다. 타입 시스템의 목적은 모든 데이터가 비트열로 보임으로써 야기되는 혼란을 방지하는 것이다.



데이터타입의 정의: 메모리 안에 저장된 데이터의 종류를 분류하는데 사용하는 메모리 집합에 관한 메타데이터다. 데이터에 대한 분류는 암시적으로 어떤 종류의 연산이 해당 데이터에 대해 수행될 수 있는지를 결정한다.



##### 객체와 타입

데이터 타입은 객체지향의 타입 사이에 깊은 견관성이 있다. 실제로 객체지향 프로그램을 작성할 때 우리는 객체를 일종의 데이터처럼 사용한다. 따라서 객체를 타입에 따라 분류하고 그 타입에 이름을 붙이는 것은 결국 프로그램에서 사용할 새로운 데이터 타입을 선언하는 것과 같다.

그렇다면 객체는 데이터인가? **그렇지 않다.** 객체의 정의를 다시 생각하자. 가장 중요한 것은 객체의 행동이다. 상태는 행동의 결과로 초래된 부수효과를 쉽게 표현하기 위해 도입한 추상적인 개념일 뿐이다.

데이터 타입과 객체의 타입은 비슷하다. 다음 두가지 조언이 있다. 객체 대신 데이터라는 말을 집어 넣어도 성립한다.

- 객체 타입을 결정하는 것은 객체가 수행하는 행동이다. 객체가 동일한 행동(데이터의 경우 덧셈, 뺄셈 등,,) 을 수행할 수 있다면 그 객체들은 동일한 타입으로 분류될 수 있다.
- 객체 내부적인 표현은 외부로부터 철저하게 감춰진다. 행동(덧셈 뺄셈)을 가장 효과적으로 수행할 수만 있다면 내부의 상태를 어떤 방식으로 표현, 설계하더라도 무방하다.

이로 끌어내는 중요한 원칙은 다음과 같다.



#### 행동이 우선이다.

동일한 책임을 수해앟는 일련의 객체는 동일한 타입에 속한다고 말할 수 있다. 이것은 객체를 타입으로 분류할 때 사용해야 하는 기준을 명확하게 제시한다. 어떤 객체를 다른 객체와 동일한 타입으로 분류하는 기준? 그 객체가 타입에 속한 다른 객체와 동일한 행동을 하기만 하면 된다. 그 안의 데이터는 관심사가 아니다.

동일한 책임이란 동일한 메시지 수신을 의미한다. 동일한 타입에 속한 객체는 내부의 데이터 표현 방식이 다르더라도 동일한 메시지를 수신하고 이를 처리할 수 있다. 다만 내부 표현 방식이 다르기 때문에 동일한 메시지를 처리하는 방식은 서로 다를 수 밖에 없다. 이것은 **다형성**에 의미를 부여한다. 다형성이란 동일한 요청에 대해 서로 다른 방식으로 응답할 수 있는 능력을 뜻한다.



#### 타입의 계층

객체가 동일한 타입으로 분류되기 위해서는 공통의 행동을 가져야만 한다. 예전에 쓰던 일반적인 휴대폰과 스마트폰을 생각해보자. 둘 다 전화가 되고 문자도 보낼 수 있지만, 스마트폰은 훨씬 더 많은 기능을 제공한다. 예전 휴대폰이 할 수 있는 기능은 모두 제공할 수도 있다. 따라서 예전 휴대폰을 스마트폰이라고 부를 수는 없다. 이 두 개념 사이의 관계를 **일반화/특수화(generalizaion/spectialization)** 관계라고 한다.



##### 일반화/특수화 관계

일반화 특수화는 동시에 일어난다. 스마트폰은 일반적인 휴대폰을 더 특수하게 표현한 것이다. 특수하다는 것은 일반적인 개념보다 범위가 더 좁다는 것을 의미하므로 휴대폰에 속하는 객체보다 그 수가 적을 수밖에 없다. 집합의 관점에서 본다면 특수한 개념을 표현하는 스마트폰은 좀 더 일반적인 개념을 표현하는 휴대폰의 부분 집합이 된다.

여기서 중요한 것은 이 일반화와 특수화 관계를 결정하는 것은 여전히 행동이라는 것이다. 더 특수한 상태를 표현한다고 해서 이런 관계가 성립하지 않다. 특수한 타입은 일반적인 타입보다 더 많은 수의 행동을 가진다. 그리고 특수한 타입은 일반적인 타입이 할 수 있는 모든 행동으르 동일하게 수행할 수 있어야 한다.



##### 슈퍼타입과 서브타입

일반화/특수화 관계는 좀 더 일반적인 타입과 좀 더 특수한 타입 간의 관계다. 이 때 좀 더 일반적인 타입을 **슈퍼타입(Suptertype)**이라고 하고 좀 더 특수한 타입을 **서브타입(Subtype)**이라고 한다. 일반적으로 서브타입은 슈퍼타입의 행위와 호환되기 때문에 서트압이느 슈퍼타입을 대체할 수 있어야 한다.



#### 정적 모델

왜 타입을 사용해야 하는가? 객체지향은 객체를 지향하는 것이므로 객체만 다루면 되지 않는가? 타입을 사용하는 이유는 인간의 인지능력으로는 시간에 따라 동적으로 변하는 객체의 복잡성을 극복하기가 너무 어렵기 때문이다.

타입은 시간에 따라 동적으로 변하는 상태를 시간과 무관한 정적인 모습으로 다룰 수 있게 해준다. 우리가 시간에 따라 키가 자라도 키라는 상태를 가진다고 단순화하면 그만이다. 타입은 상태에 복잡성을 부과하는 시간이라는 요소를 제거함으로써 시간에 독립적인 정적인 모습으로 생각할 수 있게 해준다.

**그래서 결국 타입은 추상화다.**



### 클래스

객체지향 프로그래밍 언어에서 정적인 모델은 클래스를 이용해 구현된다. 따라서 타입을 구현하는 가장 보편적인 방법은 클래스를 이용하는 것이다. '타입을 구현한다'라고 했다. 클래스와 타입은 동일한 것이 아니다. 타입은 객체를 분류하기 위해 사용되는 개념이다. 반면 클래스는 단지 타입을 구현할 수 있는 여러 구현 매커니즘 중 하나일 뿐이다. 자바스크립트와 같은 프로토 타입 기반의 언어는 클래스가 존재하지 않는다.

객체를 분류하는 기준은 <u>타입</u>이며, 타입을 나누는 기준은 객체가 수행하는 <u>행동</u>이라는 사실만을 기억하자. 객체를 분류하기 위해 타입을 결정한 후, 그를 구현할 수 있는 한 가지 방법이 클래스라는 것이다.