# 머신러닝, 딥러닝을 위한 파이썬 정리

## - Data Type



Python에는 여러 데이터타입이 있는데, 순차적으로 소개하겠다.

### Sequence data type

### 	리스트

- **호출 방법**

  ```python
  a = list()							 # 빈리스트라면 가장 많이 사용하는 방법
  a = [] 								 # 리터럴적 표현 방법
  a = [1, 2, 3]						 # 구분을 ,로 할 수 있다.
  a = [1,2,3]							 # 위와 같은 코드지만, 관용적으로 보기좋게 띄어쓰기 한칸 
  									 # 해주는 것이 좋은 코드다.
  a = [1, 3.14, 2+3j, 'hello']		 # 순서대로 integer, float, complex, string 타입
  a = [1, 2, ['hello', 4], 5, True]    # 중첩해서 사용이 가능하다.
  ```



- **인덱싱** : 시작숫자는 0이다.

  ```python
  a = [1, 2, ['hello', 4], 5, True]
  print (a[2][1])
  print (a[:1]) # 슬라이싱 하는 방법
  print (a[0])
  print (a[-2]) 
  -----------------------------------------------------------------------------------
  4
  [1]
  1
  5
  ```

  **슬라이싱**  : 기존 데이터 타입을 **유지**한다.

  - [:1] 과 같이 앞을 생략하면 처음부터란 뜻이며, 뒤의 숫자는 **포함하지 않는다.**
  - [2:5] : 2부터 시작해서 4까지 잘라서 가져오겠다란 뜻이다.
  - [1:] 마찬가지로 뒤를 생략하면 끝까지 가져온다는 뜻이다.
  - 유의깊게 봤다면 위에서 a[:1]은 결과가 [1]이고 a[0]은 결과가 1이다. 이는 슬라이싱의 특징을 잘보여준다. 개수가 1개여도 데이터타입을 유지하여 가져오기 때문에 [1]로 리스트를 가져왔다.



- **기초 연산**

```python
a = [1, 2, 3]
b = [4, 5, 6]
print( a + b ) # 연산 overloading이라 한다. 우리가 아는 +는 1+1=2지만 여기선 리스트가 확장되었다.
print( a * 3 )
# print( a[0] + 'Hello' ) # 1 + 'Hello' => '1' + 'Hello' => '1Hello'
						  # 다른 언어에서는 위처럼 생각하는게 자연스럽지만 python은 예외다.
                          # 자동으로 형변환해주지 않으며 그냥 실행하면 error가 뜬다.
print(str(a[0]) + 'Hello')# str()함수를 통해 형변환을 해줘야 한다.
-----------------------------------------------------------------------------------
[1, 2, 3, 4, 5, 6]
[1, 2, 3, 1, 2, 3, 1, 2, 3]
1Hello
```



- **부가 설명**

```python
a = [1, 2, 3]
a.append(4)    
# append() 는 리스트의 메서드이다. 메서드는 추후에 설명하겠다.
# 함수는 2가지 타입이 있다.
# 하나는 원본이 변하는 함수, 또 하나는 원본을 변화시키지 않고 값을 return해주는 함수이다.
# 다음의 예시를 보자.
print(a)
result = a.append(5) # append는 return값이 없다. 밑의 결과를 보면 none이다.
print(result)
a.append([6, 7, 8])  # 원본을 변화시키며 끝에다가 '붙이는' 역할을 한다.
print(a)

a = [1, 2, 3]
a.extend([4, 5, 6])  # 리스트를 '확장 시켜준다' append와 extend는 아래 결과의 차이를 보자
print(a)
a = [3, 6, 10, 2, 5, 7, 5, 3]
a.sort()			 # 정렬 메서드
print(a)
a.reverse()          # 거꾸로 정렬 메서드
print(a)
--------------------------------------------------------------------------------------
[1, 2, 3, 4]
None
[1, 2, 3, 4, 5, [6, 7, 8]] # append
[1, 2, 3, 4, 5, 6]		   # extend
[2, 3, 3, 5, 5, 6, 7, 10]
[10, 7, 6, 5, 5, 3, 3, 2]
```



---

### 튜플

- 리스트와 비슷하다.
- 여러가지 데이터를 순차적으로 저장하는 집합 자료형
- **읽기 전용이다.**
- **호출 방법**

```python
a = tuple() 	# 빈 튜플
a = ()  		# 리터럴적 표현
a = (1, 2, 3)
				# ()는 우선 순위 연산 즉 2 x (3 + 2) 에서 먼저 계산하라는 의미로 사용된다.
a = (1)     	# 그렇다면 왼쪽은 하나의 숫자밖에 없긴하지만 우선순위인가, 튜플인가?
print(type(a))	# 먼저 확인해보면 int 타입이다.
print(a)
a = (1,)    	# 튜플로 만들고 싶다면 이와 같이 ,하나를 붙여주면서 만들 수 있다.
print(type(a))
print(a)
--------------------------------------------------------------------------------------
<class 'int'>
1
<class 'tuple'>
(1,)
```

- **튜플 기초**

```python
a = 1, 2, 3 # 이렇게 써도 a = (1, 2, 3)
			# 그렇다 튜플은 ()를 생략할 수 있다..
print(a)

a = 1, 2, (3, 4), [5, 6], 7
print(a)
# 이렇게 써도 튜플이다.
print(a[1])
# a[1] = 3 튜플은 읽기 전용이기 때문에 이런건 할 수 없다.

a[3][0] = 100 
# 그렇지만 이건 가능하다.
# 비록 튜플안에 있어도 바뀌는 주체가 리스트의 값이라면 그건 가능하다.
print(a)

a = (1, 2, 3)
b = 4, 5, 6
print (a + b)

a = [1, 2, 3]
b = tuple(a)
# 튜플로 변환하는 방법
print(b)
result = list(b)
# 리스트로 변환하는 방법
print(a)
print(b)
print(result)
--------------------------------------------------------------------------------------
(1, 2, 3)
(1, 2, (3, 4), [5, 6], 7)
2
(1, 2, (3, 4), [100, 6], 7)
(1, 2, 3, 4, 5, 6)
(1, 2, 3)
[1, 2, 3]
(1, 2, 3)
[1, 2, 3]
```



---

### Range

- 이 역시 sequence data type이다. 바로 예시를 보자.
- **호출 방법**

```python
a = range(1, 10, 1)
# 1부터 10이전까지, 즉 1부터 9까지 1씩 증가하는 range
# 메모리를 상대적으로 조금 쓴다.
# [1, 2, 3, 4, 5, 6, 7, 8, 9] 의 리스트와 의미는 같지만 type과 메모리공간의 차이가 있다.
print(a)
a = range(10) #초기값, 증감이 없으면 각각 0, 1 이 default 값이다.
print(a)
print(a[1])  # 1
print(a[:3]) # slincing 결과도 당연히 range

a = range(3, 100, 10) #3, 13, 23, 
print(a[9])

# 추가적인 연산자로 in이 있다
# 특정요소가 연속형 자료형 안에 포함이 되어있는지 아닌지를 판별
print(7 in range(10))   # 있으니 true
print(100 in range(10)) # 없으니 false
print(range(1,20,3)[-1])    # 1, 4, 7, ... , 19
# 마지막 요소를 구하기 위해서는 -1 인덱스 쓰면 편안하다
-----------------------------------------------------------------------------------------
range(1, 10)
range(0, 10)
1
range(0, 3)
93
True
False
19
```



---

### 문자열

- 우리가 문자열이라고 부르는 것은 text sequence data type 이다.
- 사용하는 class는 str class를 이용한다.
- 다른 언어(Java, C++ 등)은 문자와 문자열을 구분하지만 Python은 구분하지 않고 모두 문자열이다.
- 'text' 와 같이 쓰거나 "text" 와 같이 쓴다. 상관없다. ~~변태처럼 혼용만 안하면 됨~~
- list안에 각 요소가 문자로 구성되었다고 생각하면 된다.
- **호출 방법**

```python
a = 'Hello'
b = 'World'
print(a + ' '+ b)

a = 'This is a Sample Text' # list라고 생각하면 됨
print(a[2:7]) 				# slicing이므로 당연히 결과도 str
print(type(a))

# 문자열은 문자열을 제어하기 위한 정말 많은 함수 제공
print(a.upper())
# upper는 리턴값임 = 원본은 변환시키지 않는다!
print(a)
-----------------------------------------------------------------------------------------
Hello World
is is
<class 'str'>
THIS IS A SAMPLE TEXT
This is a Sample Text
```

- **자주 쓰는 메서드 (`.format()`, `split()`)**

```python
apple = 522
banana = 711
text = '철수는 사과를 {}개 가지고 있고 영희는 바나나를 {}개 가지고 있어요'
text.format(apple, banana)
# format도 리턴값임!
print(text.format(apple, banana))

print('포도를 {}송이 주세요!'.format(100))

a = 'cocacola'

print(len(a))
print(a.index('a'))  # 3
a = 'this is a sample text'
result = a.split()  # 문자열을 공백으로 분할해서 각각 리스트에 넣어 리턴
print(result)

a = 'a, b, c, d, e'
result = a.split(',')  # 문자열의 기준을 , 로 정해서 리스트에 넣어 리턴
print(result)
-----------------------------------------------------------------------------------------
철수는 사과를 522개 가지고 있고 영희는 바나나를 711개 가지고 있어요
포도를 100송이 주세요!
8
3
['this', 'is', 'a', 'sample', 'text']
['a', ' b', ' c', ' d', ' e']
```



---

### Mapping data type

이전까지는 sequence data type이였다면 또다른 data type을 소개하겠다.

### 딕셔너리

- 사용되는 클래스는 dict class이다.
- dictionary는 key와 value의 쌍으로 데이터를 저장하며 기본적으로 순서의 개념이 ~~거의~~ 없다.
- **호출 방법**

```python
a = { 'name' : '홍길동', 'address' : '서울', 'age' : 25}
print(a)
print(type(a))
print(a['name'])
# dictionary는 slicing이 안된다. indexing만 가능
a['age'] = 50       # 키값이 있으면 수정해주고
a['char'] = '기타'   # 키값이 없으면 추가해줌!
print(a)

a = { 'name' : '홍길동', 'address' : '서울', 'age' : 25, 'age' : 20}
# 키가 2개면 안된다. 근데 알아서 키하나를 날리므로 쓰지말자.
print(a)

# 키값은 반드시 수정이 안되는 값으로 사용되어야 한다.
# 키값에 list는 사용할 수 없다.
# a = {[10, 20] : 'hello'} 불가능

a = { (10,20) : 'Hello'} # tuple은 사용가능 하지만 잘 사용안하고 보통 문자열을 씀
print(a)
-----------------------------------------------------------------------------------------
{'name': '홍길동', 'address': '서울', 'age': 25}
<class 'dict'>
홍길동
{'name': '홍길동', 'address': '서울', 'age': 50, 'char': '기타'}
{'name': '홍길동', 'address': '서울', 'age': 20}
{(10, 20): 'Hello'}
```

- **Dictionary를 쓰면 꼭 알아야 하는 메서드**

```python
# keys(), values(), items()
a = { 'name' : '홍길동', 'address' : '서울', 'age' : 20}
print(a.keys())
# list 형태로 준다. 근데 조금 다르다. 결과를 보면

# dict_keys(['name', 'address', 'age'])
# ['name', 'address', 'age']
# 위의 결과는 보면 다른 class는 맞지만 같은 list처럼 사용할 수 있다.

print(a.values())
print(a.items()) # 튜플로 묶어서 하나의 리스트로 넣어 리턴해줌
# items 를 사용하면 리스트로 반환하기 때문에 index를 사용할 수 있다
# 따라서 순차적 처리할때 items를 쓴다.
-----------------------------------------------------------------------------------------
dict_keys(['name', 'address', 'age'])
dict_values(['홍길동', '서울', 20])
dict_items([('name', '홍길동'), ('address', '서울'), ('age', 20)])
```



---

### Set

- 사용되는 class는 set이다.
- 주머니처럼 생각하자 순서가없다.
- key와 value의 개념이 없고 그냥 데이터 덩어리라고 생각하면 된다.
- 데이터의 중복이 허용되지 않는다.
- 생김새가 dictionary와 같다.
- key와 value의 쌍이 아니라 그냥 구겨 넣으면 set이다.
- **호출 방법**

```python
a = {1, 2, 3, 4, 4} # 4 하나는 사라짐
print(type(a))
print(a)

a = [1, 2, 1, 2, 3, 5, 6, 4]
print(type(a))
print(a)

result = set(a)
# set으로 변환
print(type(result))
print(result)

# set의 연산
# 집합연산(합집합, 교집합, 차집합)

a = set([1, 8, 3, 4]) # 보이는 것만 정렬해주는 것이지 순서는 상관없다.
b = set([3, 4, 5, 6])
print(a | b) # 합집합(union)
print(a & b) # 교집합(intersection)
print(a - b) # 차집합(differnce)
-----------------------------------------------------------------------------------------
<class 'set'>
{1, 2, 3, 4}
<class 'list'>
[1, 2, 1, 2, 3, 5, 6, 4]
<class 'set'>
{1, 2, 3, 4, 5, 6}
{1, 3, 4, 5, 6, 8}
{3, 4}
{8, 1}
```



---

### Python data type



### Bool

- True, False로 이뤄진 데이터이다. (대,소문자주의)
- **호출 방법**

```python
# python data type - Bool Type
# True, False
a = True
b = False
print(a and b) # and는 둘다 true여야만 true
print(a or b)
print(not a)

# 비어있는 데이터들은 False로 간주함.
# '', "", [], (), {}, None => false
# 숫자 0은 False 이외에는 True
-----------------------------------------------------------------------------------------
False
True
False
```



- 또 다른 Python의 built-in data type으로 날짜 연산에 사용되는 data class도 있는데 나중에 다시 하겠다.

