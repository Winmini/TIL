# Developer Tools



### 애플리케이션 시작 시간 단축

코드를 수정할 때마다 변경사항을 애플리케이션에 반영하기 위해, 애플리케이션을 계속 재시작한다. 그리고 부팅시간은 생각보다 오래걸리는데, 만약 WAR 파일을 만들고 애플리케이션에 배포까지 해야 하는 상황이라면 애플리케이션 재시작은 정말 오래 걸린다. IDE는 이 과정을 자동으로 최적화해서 수행하지만, 그럼에도 오래 걸린다.

스프링 부트가 나오기 한참 전부터 스프링 프레임워크는 무거운 애플리케이션 서버 대신 서블릿 컨테이너를 선택해서 재시작 문제 해결을 시도했지만 생각보다 충분치 않았다. 스프링 부트가 나오면서 많은 개선을 했다.



### 개발자 도구

이를 더해서 DevTools라는 새로운 개발자 도구를 만들어냈다. 개발자 도구 모듈에 포함된 기능은 다음과 같다.

- 애플리케이션 재시작과 리로드 자동화
- 환경설정 정보 기본값 제공
- 자동설정 변경사항 로깅
- 정적 자원 제외
- 라이브 리로드 지원

디펜던시에 다음을 추가하자.

```java
developmentOnly 'org.springframework.boot:spring-boot-devtools'
```

새로운 것을 저장하거나 빌드 (IDE 설정마다 다름)만으로 빠르게 재부팅하는 효과를 얻을 수 있다.



### 리액터 개발자 도구

리액터 플로우중에 무언가 잘못되어도 대응하기가 힘들다. 리액터 처리과정이 여러 스레드에 걸쳐 수행될 수 있으므로 스택 트레이스를 통해 쉽게 확인이 불가능하다. 구독에 의해 실행되는 작업 흐름을 조립하는 비동기, 논블로킹 연산을 수행한다. 그리고 연산은 수행하는 스레드가 어떤 스레드일지 보장되지 않는다. 근데 자바 스택 트레이스는 동일한 스레드만 가능하다. 스택 트레이스에 많은 내용이 출력되어도 순서가 보장이 안되어 큰 의미없는 정보다. 이러한 한계를 극복하게 하는 것이 리액터의 `Hooks.onOperatorDebug()` 메서드이다.

```java
public class DebugTest {
	@Test
	void debugTest() {
		Hooks.onOperatorDebug();
		Mono<Integer> source;

		if (new Random().nextBoolean()) {
			source = Flux.range(1, 10).elementAt(5);
		} else {
			source = Flux.just(1, 2, 3, 4).elementAt(5);
		}

		source.subscribeOn(Schedulers.parallel()).block();
	}
}
```

테스트 해보면, 오류가 우리가 늘 보던 것처럼 순차적으로 실행된 결과를 알려준다. 스레드 경계를 넘어서서 오류 관련 핵심 정보를 가져다주니, 유용하다.

리액터 자체로는 JVM이 지원하지 않지만, Hooks.onOperatorDebug()를 호출하면 리액터가 처리 흐름 조립 시점에서의 호출부 세부정보를 수집하고 구독해서 실행되는 시점에 세부 정보를 넘겨준다.

**참고**

스택정보를 스레드 경계를 넘어서 전달하려면 굉장히 많은 비용을 치뤄야 한다. 그래서 기본적으로 자바에서 스레드 경계를 넘어서 정보를 전달하는 것을 허용하지 않는다. 그 말은 이 메서드는 실제 운영환경에서 사용하면 절대 안된다는 말이다. 버그를 추적할 환경에서만 사용해서 확인하고 그 외엔 사용하지 말자.



#### 플로우 로깅

리액터는 실행 후 말고 실행될 때 로그를 남길 수도 있다. `log` 를 중간에 그냥 껴넣으면 나온다. 사용법이 매우 쉬우므로 자주 쓰인다.



## 블록하운드

리액티브 프로그래밍은 가뜩이나 배우기도 힘들고, 적용하는 것도 머리를 많이 쓴다. 근데 힘들게 적용했는데 진짜 멀리 구석에 존재감 없는 개발자가 블로킹 API를 **한 번이라도 호출하면** 아무 소용이 없다. 단 한 사람으로 인해 시스템이 걷잡을 수 없도록 느려지는 위험이 있다. 이는 방치하면 절대 안된다.

**블록하운드**가 블로킹 코드가 어디에도 없다는 것을 보장해준다. 리액터 개발팀에 소속된 세르게이 에고로프가 만들었으며, 개발자가 직접 작성한 코드 뿐만 아니라 라이브러리에 사용된 블로킹 메서드 호출을 모두 찾아내서 알려준다. JDK 자체에서 호출되는 블로킹 코드까지도 찾아낸다. 이를 사용하기 위해 빌드 파일에 내용을 추가하자.

```java
implementation 'io.projectreactor.tools:blockhound:1.0.6.RELEASE'
```

그리고 우리의 애플리케이션이 시작하기 전에 코드를 다음과 같이 적으면 된다.

```java
@SpringBootApplication
public class ComputerApplication {

	public static void main(String[] args) {
		BlockHound.install();
		SpringApplication.run(ComputerApplication.class, args);
	}

}
```

이렇게 해야 블록하운드가 바이트코드를 조작할 수 있게 된다. 그리고 시작하면 애플리케이션이 정상적으로 시작된다. 그리고 원하는 작업을 수행했을 때 블로킹이 걸리는 것이 있으면, 로그에 오류가 출력된다. `Blocking call!` 로 알려준다. 블로킹 코드가 단 하나라도 포함되면 리액티브 프로그래밍은 제대로 동작하지 않는다.