# Web



- Java 11
- Gradle Project
- Spring Boot 2.6.7
- Jar
- Spring Reactive Web, Spring Data Reactive MongoDB, Lombok

위와 같이 세팅을 마치고 생성한 다음, 프로젝트를 열면 스프링 부트는 처음과 같은 애플리케이션 파일을 자동으로 만들어준다.

```java
@SpringBootApplication
public class ComputerApplication {
	public static void main(String[] args) {
		SpringApplication.run(ComputerApplication.class, args);
	}
}
```

`@SpringBookApplication` 은 autoconfiguration과 component scanning 기능을 포함하는 복합 애너테이션이다. main은 애플리케이션을 실행하는 함수며, `run` 코드는 이 클래스를 애플리케이션 시작점으로 등록하는 스프링 부트 훅이다.

이 클래스는 웹 컨테이너에 설치할 필요가 없는 애플리케이션이라고 하는 것이다. 이게 어떻게 가능할까?



#### AutoConfiguration

스프링 부트에는 자동설정 기능이 포함되어 있다. 설정 내용을 분석해서 발견되는 정보에 맞게 다양한 빈을 자동으로 활성화하는 조건 분기 로직이다.

- 클래스 패스
- 다양한 설정 파일
- 특정 빈의 존재 여부 등등

여러 측면을 살펴보고 유추한 다음 다양한 컴포넌트를 자동으로 활성화한다. 뒤에서 볼 `WebFluxAutoConfiguration` 빈은 다음 조건이 충족될 때만 활성화된다.

1. 리액티브 컨테이너 존재
2. 클래스패스에 스프링 웹플럭스 존재
3. WebFluxConfigurationSupport 타입 빈의 부존재

웹 컨테이너는 프로젝트 리액터에 맞도록 네티를 감싸서 만든 리액터 네티이다. 참고로 3번도 의미를 가지는 것이 만약 내가 직접 만든 빈을 활성화시키면 자동설정에 의해 생성된 빈이 생성되지 않기 때문이며, 이것이 스프링 부트에서 빛나는 기능이다. 해당 설정이 있으면 지정한대로 하고 기존 부분은 무효화시키기 때문이다.



#### Component Scan

스프링이 빈을 등록하는 방식은 환경설정 클래스에서 직접 하나하나 빈으로 등록할 수 있다. 또는 빈의 존재를 플래그로 표시하고 컴포넌트 탐색을 통해 자동으로 빈을 찾아내고 등록하게 할 수도 있다. 스프링 애플리케이션이 실행되면 모든 빈은 애플리케이션 컨텍스트에 등록된다.



스프링 웹플럭스의 컨트롤러를 만들어보자.

```java
@RestController
@RequiredArgsConstructor
public class HomeController {

	private final KitchenService service;

	@GetMapping(value = "/server", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
	public Flux<Dish> serveDishes(){
		return service.getDishes();
	}
}
```

반환되는 미디어 타입은 `text/event-stream` 이고, 클라이언트는 서버가 반환하는 스트림을 쉽게 소비할 수 있다. `Flux`를 반환하는 것은 Collection과 차이가 있다. 그 중 가장 큰 차이점은 비동기적으로 전달된다는 점이다. 이 전달 방식은 리액터와 네티에서 담당한다. 구독 역시, 스프링 웹플럭스가 구독한다. 컨트롤러 메서드에서 리액터 타입을 반환하도록 작성하면 스프링 웹플럭스가 적절한 옵션과 함께 적절한 타이밍에 구독한다.

비즈니스 로직도 만들어보자.

```java
@Service
public class KitchenServiceImpl implements KitchenService{

	private final List<Dish> menu = List.of(new Dish("Sesame chicken"),
		new Dish("Lo mein noodles, plain"),
		new Dish("Sweet & sour beef"));
	private final Random picker = new Random();

	/**
	 * 요리 스트림 생성
	 */
	@Override
	public Flux<Dish> getDishes() {
		return Flux.<Dish> generate(sink -> sink.next(randomDish()))
			.delayElements(Duration.ofMillis(250));
	}

	private Dish randomDish() {
		return menu.get(picker.nextInt(menu.size()));
	}
}
```

기존의 `just`가 아니라, `generate()`를 사용해서 연속적으로 계속 만들어 제공해준다. 요리 제공속도도 조절해서 250밀리초마다 하나의 요리를 제공한다. 사용한 도메인 객체는 다음과 같다.

```java
@Getter
@ToString
@RequiredArgsConstructor
public class Dish {

	private final String name;
	private boolean delivered = false;
	
	public static Dish deliver(Dish dish) {
		Dish deliveredDish = new Dish(dish.name);
		deliveredDish.delivered = true;
		return deliveredDish;
	}
	
	public boolean isDelivered() {
		return delivered;
	}
}
```

Setter는 사용하지 않았으며, 불변 객체로 만들기 위해 이와 같이 작성하였다.

서버를 실행시키고 호출하면 다음과 같이 무한하게 뜬다.

```
data:{"name":"Lo mein noodles, plain","delivered":false}

data:{"name":"Sweet & sour beef","delivered":false}

data:{"name":"Lo mein noodles, plain","delivered":false}

data:{"name":"Sesame chicken","delivered":false}

data:{"name":"Sesame chicken","delivered":false}

data:{"name":"Sweet & sour beef","delivered":false}

...
```

종료되지 않고 결과가 계속 출력되니 강제 종료하자. 깊이 이해하진 않아도 스트리밍 방식으로 동작하는 웹 서비스를 만든 것이다. 뷰 리졸버, 웹 메서드 핸들러 등 여러 빈을 등록하지 않아도 스프링 부트가 다 만들어주었기 때문이다.

이제 서빙되었다는 값도 map을 이용해보자.

```java
@GetMapping( value = "/served-dishes", produces = TEXT_EVENT_STREAM_VALUE)
public Flux<Dish> deliverDish() {
  return service.getDishes()
    .map(Dish::deliver);
}
```

그리고 결과를 살펴보자.

```
data:{"name":"Lo mein noodles, plain","delivered":true}

data:{"name":"Lo mein noodles, plain","delivered":true}

data:{"name":"Sweet & sour beef","delivered":true}

data:{"name":"Sesame chicken","delivered":true}

data:{"name":"Sesame chicken","delivered":true}
```

이젠 배달이 완료되었다는 true로 반환해준다. `deliever()` 매핑 함수를 사용해서 변환한 후에 반환하기 때문이다.

이 코드처럼 상태를 바꾸거나 아예 다른 결과로 반환할 수 있다는 것도 어렵지 않음을 알 수 있다. 정말로 컨슈머가 원하는 전혀 다른 객체도 반환할 수 있는 것이다.



### 참고

데이터를 변환하는 것은 어느 계층에서든 쉽게 가능하다. 하지만 스프링 부트 프로젝트 리더인 필 웹은 웹 컨트롤러를 가능한 한 가볍게 가져가는 것을 추천한다. 웹 컨트롤러에는 비즈니스 로직을 담지 말고, 웹 요청 내용을 해석해서 **적절한 서비스 메서드에 처리를 위임하고 결과물을 반환하는 역할**을 부여하는 편이 좋다. 웹 컨트롤러는 GET 요청을 받으면 해당 서비스를 호출해서 서비스 메서드가 반환하는 데이터를 클라이언트에 전송할 수 있도록 직렬화 한다. PUT이나 POST의 요청이라면 요청에 포함된 입력데이터를 추출하고 적절한 메서드에 전달하는 역할을 담당한다.



### 메인에 장바구니를 뿌려보자.

```java
@Override
public Mono<Cart> findOne(String id) {
  return cartRepository.findById(id)
    .defaultIfEmpty(new Cart())
    .flatMap(cart -> cart.getCartItems().stream()
             .filter(cartItem -> cartItem.getItem().getId().equals(id))
             .findAny()
             .map(cartItem -> {
               cartItem.increment();
               return Mono.just(cart);
             })
             .orElseGet(() -> {
               return itemRepository.findById(id)
                 .map(CartItem::new)
                 .map(cartItem -> {
                   cart.getCartItems().add(cartItem);
                   return cart;
                 });
             }))
    .flatMap(cartRepository::save);
}
```

스트림을 자유 자재로 사용할 수 있다는 것을 전제로 한다. 만약 모른다면 모던 자바인 액션의 책을 강추한다.

근데 스트림에 익숙하지 않으면 위 코드가 매우 복잡해보이고, 어려워보일 수 있다. 전통적인 반복문과 스트림 API의 차이는 크다. 익숙한 전통 반복문을 만들면,

```java
for (CartItem cartItem : cart.getCartItems()) {
  if (cartItem.getItem().getId().equals("5")){
    found = true;
  }
} 

if (found){
  // 수량증가
} else{
  // 새 항목 추가
}
```

오히려 이게 보기 좋아보인다. 하지만 리액티브 프로그램이인 이런 방식을 사용하지 않는다.

가장 큰 이유는 side effect이다. 명령형 프로그래밍에서는 모든 로컬 변수에 부수 효과가 발생할 수 있다. 상태를 만들면 이 상태 값을 바꿀 수 있는 수많은 다른 API를 거치면서 상태가 어떻게 변경되는지 파악하기 어려워진다. 스트림 API는 이런 단점을 극복할 수 있다.

중간 상태가 없어서 초깃값 문제나, 값을 잘못 변경하는 위험이 아예 사라진다. 따라서 좋은 방식이다.