# Data Access



데이터 없는 애플리케이션은 어느 누구도 만들지 않는다. 단순한 애플리케이션은 외부 서비스 연계나 메시지 브로커 연결이 전혀 필요없기도, 보안을 엄격하게 하지 않아도 되는 내부용 애플리케이션도 있다. 하지만 데이터를 저장하고 조회할 수 있는 데이터베이스와 연결하지 않는 애플리케이션은 없다.

이번엔 다음에 대해 공부해보자.

- 리액티브 데이터 스토어의 요건
- 이커머스 애플리케이션 도메인 객체 정의
- 객체를 저장하고 조회할 리포지토리 생성
- 상기 내용을 서비스에 적용



### 리액티브 데이터 스토어의 요건

데이터베이스에 데이터를 밀어 넣기 전, 리액티브 프로그래밍의 핵심 요건을 이해해야 한다. 리액티브 프로그래밍을 사용하려면 **모든 과정이 리액티브여야 한다.**

웹 컨트롤러를 리액티브 방식으로, 서비스 계층도 리액티브 방식으로 만들었는데, 블로킹 방식으로 연결되는 데이터베이스를 호출하면 리액티브는 무너진다. 리액터 기반의 애플리케이션은 적은 스레드를 가지고 있으므로 블로킹이 존재하면 스레드가 금방 고갈되어 망가진다. 레거시 블로킹 코드를 따로 감싸서 해결하는 방법도 리액티브의 장점을 잃게 된다.

리액티브의 선입견중 하나는 태생적으로 빠르다는 주장이다. 이는 틀렸다. 작업을 수행하는 단일 스레드의 처리 속도 기준으로 보면, 리액티브 프로그래밍은 여러가지 오버 헤드를 수반하므로 오히려 성능 저하가 발생한다. 작업량을 대규모로 늘려야 하는 상황이 아니라면, 시스템은 더 느리게 동작한다.

아무쪼록 리액티브가 제대로 동작하려면 데이터베이스 역시 리액티브하게 동작해야 한다. 어떤 데이터 베이스가 최신형 리액티브 패러다임을 지원하고 있을까?

- MongoDB
- Redis
- Cassandra
- ElasticSearch
- Neo4j
- Couchbase

선택의 폭이 아주 넓지는 않다. 실제로 현장에 사용중인 데이터베이스의 80%는 관계형 DB이다. 하지만 위 목록엔 단 하나도 없다. 이유는 간단하다. 자바에서 관계형 DB를 사용할 때 다음과 같은 기술이 사용된다.

- JDBC
- JPA
- Jdbi
- JOOQ

이 외에도 몇개 더있지만 그 대부분은 이 4가지 기술을 더 쓰기 편하게 감싼 것들이다. JPA와 JDBC 기본적으로 블로킹 API다. 트랜잭션을 시작하는 메시지를 전송하고, 쿼리를 포함하는 메시지를 전송하고, 결과가 나올 때 클라이언트에게 스트리밍해주는 개념 자체가 없다. 모든 **데이터 베이스 호출은 응답을 받을 때까지 블로킹되어 기다려야 한다.** 이를 감싸서 리액티브 스트림 계층에서 사용할 수 있게 해주는 반쪽짜리 솔루션도 있다. 하지만 이런 솔루션은 내부 스레드 풀을 사용해서 동작하는데, 이 역시 문제다.

코어의 수보다 많은 스레드를 사용하는 것은 장점이 거의 없다. 4코어 장비면 4개의 스레드로 구성된 스레드 풀을 사용하는 것이 좋다. 4코어 장비에 100개의 스레드를 만들면 컨텍스트 스위칭 오버헤드가 증가하고 효율이 급격히 떨어지게 된다.

실제로 Node.js 를 보면 비동기, 논블로킹 방식으로 동작하는 단일 스레드 애플리케이션이 블로킹 방식으로 동작하면서 스레드를 100개 사용하는 애플리케이션보다 처리량이 더 높게 나온다는 것을 입증했다.



스프링 부트를 Webflux로 만들어 다음과 같은 의존을 추가하자.

```java
dependencies {
	implementation 'org.springframework.boot:spring-boot-starter-data-mongodb-reactive'
	implementation 'org.springframework.boot:spring-boot-starter-webflux'
	implementation 'de.flapdoodle.embed:de.flapdoodle.embed.mongo'
	implementation 'org.mongodb:mongodb-driver-sync'
	compileOnly 'org.projectlombok:lombok'
	annotationProcessor 'org.projectlombok:lombok'
	testImplementation 'org.springframework.boot:spring-boot-starter-test'
	testImplementation 'io.projectreactor:reactor-test'
}
```

몽고디비 리액티브 버전, 그리고 flapdoodle은 내장형 몽고디비 도구이다. 테스트에 주로 사용하며 초기 설계 단계에서 데이터 스토어로 사용할 수 있다.`driver-sync`는 리액티브가 아닌 전통적인 몽고디비 드라이버 이며, 테스트 데이터 로딩에서 자세히 보자.



### 이커머스 도메인 정의

| 도메인 객체 | 설명                          |
| ------ | --------------------------- |
| 판매 상품  | 일련번호, 가격, 설명 필요             |
| 장바구니   | 장바구니 식별자와 장바구니에 담긴 상품 목록 필요 |
| 구매 상품  | 장바구니에 담긴 판매 상품의 구매 수량 필요    |

엔티티 모델링이나 도메인 주도 설계 등은 별도로 공부하자.

스프링 데이터 몽고디비를 사용하므로 어떤 필드를 몽고디비의 ObjectId 값으로 사용할지 결정해야 한다. 몽고디비에 저장할 객체를 정의할 때는 **몽고디비 애너테이션을 사용하는 등 추천할 만한 권장 사례를 따르는 것이 좋다.** 모든 데이터 스토어에 범용적으로 적용할 수 있는 유일한 해법 같은 것은 없다. 레디스를 사용할 때 썼던 그대로 몽고 디비에서도 동작할 것이라고 기대해서는 안된다.



업계에서는 NoSQL 데이터 스토어를 표준화하는 방법을 찾기 위해 다양한 시도를 했지만 성공한적이 없다. 모두 엔진이 다르며 장단점이 있고, 상충되는 부분이 존재하기 때문이다. 이렇게 서로 다른 엔진을 하나의 API로 통일해서 표준화하려면 매우 복잡한 과정을 거쳐야 한다. 다만 그렇게 해도 고유한 특성을 잃게 되어 결국은 실패로 이어져 권장하지 않는다. 스프링 데이터는 어떻게 해결할까?

스프링이 가진 가장 강력한 패러다임 중 하나는 **템플릿 패턴**이다. 템플릿이라는 이름이 붙은 이 다양한 도구는 타입 안전방식으로 연산을 처리하고 다루기 복잡하고 귀찮은 것들은 추상화했다. 몽고디비용으로는 몽고템플릿, 리액티브몽고템플릿이 제공된다. 하나의 데이터 스토어만을 위한 맞춤형 템플릿이라, 풍부한 기능을 모두 활용할 수 있다.

```java
public interface ItemRepository extends ReactiveCrudRepository<Item, String> {
}
```

스프링 데이터 JPA를 공부했다면 비슷한 느낌을 받을 수 있다. 그리고 키워드도 다 비슷하다. 눈여겨볼 점은 모든 메서드의 반환 타입이 Mono나 Flux 둘 중 하나라는 점이다. 이부분이 매우 중요하다. 구독하고 있다가 몽고디비가 데이터를 제공할 준비가 됐을 때 데이터를 받을 수 있다.

근데 그 동안을 생각하면 다음과 같은 코드를 쓸 수 있다.

```java
itemRepository.save(item);
```

판매 상품을 저장하려면 위와 같은 코드를 작성할 수 있지만. 문제가 있다. save는 Mono를 반환한다. 이 Mono느느 구독하기 전까진 아무 일도 하지 않는다. 즉 일을 하게 하려면 다음과 같이 구독해야 한다.

```java
itemRepository.save(item).subscribe();
```

구독했으니 아무런 문제가 없어보이지만 여전히 있다.

늘 문제가 되는 것은 아니고, 애플리케이션 시작하는 과정에서 문제가 될 수 있다. 네티가 시작되면 구독자가 애플리케이션 시작 스레드로 하여금 이벤트 루프를 데드락 상태에 빠뜨릴 수 있다.

따라서 애플리케이션 **시작 시점에 어떤 작업을 하려면**, 블로킹 버전의 스프링 데이터 몽고디비를 사용하는 것이 좋다.

```java
public interface BlockingItemRepository extends CrudRepository<Item, String> {
}
```

이렇게 블로킹 레포지토리를 사용할 수 있다. 다만 **운영중에는 안된다**!

다시 나오는 문제다. 운영중에는 절대 안된다. 절대다. 근데 이렇게 만들어놓으면 누군가가 이를 사용해버릴 위험이 존재한다. 그래서 아예 만들지 말아야 한다. 그래서 이를 안만들고 다음과 같이 시작할때 로더클래스를 만들자.

```java
@Component
public class TemplateDatabaseLoader {
	
	@Bean
	public CommandLineRunner initialize(MongoOperations mongo){
		return args -> {
			mongo.save(new Item.Builder().name("itemA").price(1000).build());
			mongo.save(new Item.Builder().name("itemB").price(2000).build());
		};
	}
}
```

`MongoOperations`는 스프링이 `JdbcTemplate`에서 일부를 추출해 `JdbcOperations`라는 인터페이스를 만들었었다. 이 인터페이스를 사용하면 계약과 세부 구현 내용을 분리할 수 있는데, 이 패턴은 거의 모든 템플릿에서 사용되고 있으며 결합도를 낮추는 인터페이스다.

