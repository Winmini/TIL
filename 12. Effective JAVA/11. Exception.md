# Exception



예외는 제대로 활용하면 장점이 많아지지만, 잘못 사용하면 그게 다 단점이 된다. 사용 방법에 대하여 알아보자.

### 예외는 진짜 예외 상황에만 사용하라

~~운이 없다면~~ 언젠가 다음과 같은 코드를 마주칠 수 있다.

```java
try{
  int i = 0;
  while(true)
    range[i++].climb();
} catch (ArrayIndexOutOfBoundsException e){
}
```

먼저 무슨일을 하는 코드인지 알 수 없는 것만으로도 이렇게 작성하면 안되는 이유로 충분하다. 심지어 속도도 저자 컴퓨터 기준으로 2배나 느렸다. 표준적인 관용구를 사용하도록 하자.

예외는 그 이름이 말해주듯 오직 예외상황에서만 써야 하며, 일상적인 제어 흐름용으로 쓰여선 안된다. 성능 개선을 이유로도 쓰지마라. 실제로 좋아지더라도 자바 플랫폼이 꾸준히 개선되고 있어 그 우위는 오래가지 않을 가능성이 있고, 유지보수 문제는 계속 이어질 것이다.



### 복구할 수 있는 상황에는 검사 예외를, 프로그래밍 오류에는 런타임 예외를 사용하라

자바는 문제 상황을 알리는 타입으로 검사 예외, 런타임 예외, 에러 이렇게 세 가지를 제공한다. 언제나 100% 명확한 건 아니지만 좋은 지침이 있다.

<u>호출하는 쪽에서 복구하리라 여겨지는 상황이라면 검사 예외를 사용하라.</u> 이것이 검사와 비검사 예외를 구분하는 기본 규칙이다. 검사 예외를 던지면 호출자가 그 예외를 catch로 잡아 처리하거나 더 바깥으로 전파하도록 강제하게 된다. 비검사 throwable은 두 가지로, 바로 런타임 예외와 에러다. 둘 다 동작 측면에서는 다르지 않다. 이 둘은 프로그램에서 잡을 필요가 없거나 혹은 통상적으로 잡지 말아야 한다. 프로그램에서 비검사 예외나 에러를 던졌다는 것은 복구가 불가능하거나 더 실행해봐야 득보다는 실이 많다는 뜻이다. 이런 throwable을 잡지 않은 스레드는 적절한 오류 메시지를 내뱉으며 중단된다.

프로그래밍 오류를 나타낼 때는 런타임 예외를 사용하자. 런타임 예외의 대부분은 전제조건을 만족하지 못했을 때 발생한다. 전제조건 위배란 단순히 클라이언트가 해당 API의 명세에 기록된 제약을 지키지 못했다는 뜻이다. 예컨대 배열의 인덱스는 0에서 '배열크기-1' 이여야 한다. 바운드 익셉션이 발생했단 건 이 전제 조건이 지켜지지 않았다는 뜻이다. 이상의 조건에서 문제가 하나 있다면, 복구할 수 있는 상황인지 프로그래밍 오류인지가 항상 명확히 구분되지는 않는다는 사실이다. 복구 가능하다고 믿는다면 검사 예외를, 그렇지 않다면 런타임 예외를 사용하자.

에러는 보통 JVM이 자원 부족, 불변식 깨짐 등 더 이상 수행을 계속할 수 없는 상황을 나타낼 때 사용한다. Error 클래스를 상속해 하위 클래스를 만드는 일은 자제하기 바란다. 우기가 구현하는 비검사 throwable은 모두 RuntimeException의 하위 클래스여야 한다.

예외의 메서드는 주로 그 예외를 일으킨 상황에 관한 정보를 코드 형태로 전달하는 데 쓰인다. 이런 메서드가 없다면 프로그래머들은 오류 메시지를 파싱해 정보를 빼내야 하는데, 대단히 나쁜 습관이다.

throwable 클래스들은 대부분 오류 메시지 포맷을 상세히 기술하지 않는데, 이는 JVM이나 릴리스에 따라 포맷이 달라질 수 있다는 뜻이다. 따라서 메시지 문자열을 파싱해 얻은 코드는 깨지기 쉽고 다른 환경에서 동작하지 않을 수 있다.



### 필요 없는 검사 예외사용은 피하라

검사 예외를 회피하는 가장 쉬운 방법은 적절한 결과 타입을 담은 옵셔널을 반환하는 것이다. 검사 예외를 던지는 대신 단순히 빈 옵셔널을 반환하면 된다.  아니면 다른 방법으로 검사 예외를 던지는 메서드를 2개로 쪼개 비검사 예외로 바꿀 수 있다. 상태 검사 메서드와 예외상황에 대처하는 코드를 if로 쪼개는 방식이다.

그리고 예외의 사용은 표준 예외를 사용하도록 하자. 단 예외는 직렬화할 수 있다는 사실을 기억하자. 이 사실만으로도 나만의 예외를 새로 만들지 않아야 할 근거로 충분할 수 있다.



### 추상화 수준에 맞는 예외를 던지라

수행하려는 일과 관련 없어 보이는 예외가 튀어나오면 당황스러울 것이고, 메서드가 저수준 예외를 처리하지 않고 바깥으로 전파해버릴 때 종종 일어나는 일이다. 사실 이는 프로그래머를 당황시키는 데 그치지 않고 내부 구현 방식을 드러내어 윗 레벨 API를 오염시킨다.

이 문제를 피하려면 상위 계층에서는 저수준 예외를 잡아 자신의 추상화 수준에 맞는 예외로 바꿔 던져야 한다. 이를 예외 번역(exception translation)이라 한다.

```java
try {
  ... // 저수준 추상화를 이용한다.
} catch (LowerLevelException e) {
  throw new HigherLevelException(...);
}
```

다음은 AbstractSequentialList에서 수행하는 예외 번역의 예다. 

예외를 번역할 때, 저수준 예외가 디버깅에 도움이 된다면 예외 연쇄를 사용하는게 좋다. 예외 연쇠란 문제의 근본 원인인 저수준 예외를 고수준 예외에 실어 보내는 방식이다. 그러면 별도의 접근자 메서드를 통해 필요하면 언제든 저수준 예외를 꺼내볼 수 있다.

나중에 더 자세히 확인하자.



### 가능한 한 실패 원자적으로 만들라

작업 고중 예외가 발생해도 그 객체는 여전히 정상적으로 사용할 수 있는 상태라면 훨씬 좋을 것이다. 검사 예외를 던진 경우라면 호출자가 오류 상태를 복구할 수 있을 테니 특히 더 유용할 것이다. 일반화해 이야기 하면, <u>호출된 메서드가 실패하더라도 해당 객체는 메서드 호출 전 상태를 유지해야 한다.</u>

이렇게 하는 가장 간단한 방법은 불변 객체로 설계하는 것이다. 불변 객체는 태생적으로 실패 원자적이다. 메서드가 실패하면 새로운 객체가 만들어지지는 않을 수 있으나 기존 객체가 불안정한 상태에 빠지는 일은 결코 없다.

가변 객체의 메서드를 실패 원자적으로 만드는 가장 흔한 방법은 작업 수행에 앞서 매개변수의 유효성을 검사하는 것이다. 객체의 내부 상태를 변경하기 전에 잠재적 예외의 가능성을 대부분 걸러낼 수 있는 방법이다.

세 번째 방법은 객체의 임시복사본에서 작업을 수행한 다음 원래 객체와 교체하는 것이다. 예를 들어 어떤 정렬 메서드에서는 정렬을 수행하기 전에 입력 리스트의 원소들을 배열로 옮겨 담는다. 배열을 사용하면 훨씬 빠르게 접근할 수 있기 때문이다.