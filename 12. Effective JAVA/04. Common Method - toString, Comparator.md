# Common Method



### toString을 항상 재정의하라

object의 기본 toString 메서드가 우리가 작성한 클래스에 적합한 문자열을 반환하는 경우는 거의 없다. 이 메서드는 단순히 클래스이름@해시코드를 반환할 뿐이다. toString의 일반 규약에 따르면 '간결하면서 사람이 읽기 쉬운 형태의 유익한 정보'를 반환해야 한다. 클래스이름이 PhoneNumber일 경우 전화번호를 직접 알려주는 형태가 훨씬 유익한 정보를 담고 있다. 또한 toString의 규약은 <u>모든 하위 클래스에서 이 메서드를 재정의하라</u>고 한다.

equals와 hashCode 규약만큼 대단히 중요하진 않지만, toString을 잘 구현한 클래스는 사용하기에 훨씬 즐겁고, 그 클래스를 사용한 시스템은 디버깅하기 쉽다. 제대로 정의하지 않으면 쓸모없는 메시지만 로그에 남는다. 가령 다음과 같이 코드를 구현한다 생각해보라.

```java
System.out.println(phoneNumber + "에 연결할 수 없습니다.");
```

toString을 재정의했든 아니든 이렇게 진단 메시지를 만들 것이다. 근데 재정의를 안했으면 그다지 쓸모가 없는 메시지가 출력된다. 좋은 toString은 특히 컬렉션처럼 이 인스턴스를 포함하는 객체에서 유용하게 쓰인다.

실전에서 toString은 그 객체가 가진 주요 정보 모두를 반환하는 게 좋다. 그리고 toString을 구현할 때면 반환값의 포맷을 문서화할지 정해야 한다. 전화번호나 행렬 같은 값 클래스라면 문서화하기를 권한다. 포맷을 명시하기로 했다면, 명시한 포맷에 맞는 문자열과 객체를 상호 전환할 수 있는 정적 팩터리나 생성자를 함께 제공해주면 좋다. 자바 플랫폼의 많은 값 클래스가 따르는 방식이기도 하다.

포맷 명시 여부와 상관없이 toString이 반환한 값에 포함된 정보를 얻어올 수 있는 API를 제공하자. 예컨대 PhoneNumber 클래스는 지역코드, 프리픽스, 가입자 번호용 접근자를 제공해야 한다. 그렇지 않으면 이 정보가 필요한 프로그래머스는 toString의 반환값을 파싱할 수 밖에 없다.

정적 유틸리티 클래스는 toString을 제공할 이유가없고, 대부분의 열거 타입도 toString을 제공하니 따로 필요 없다.



### Comparable을 구현할지 고려하라

이번엔 Comparable 인터페이스의 유일무이한 메서드 compareTo를 알아보자. 성격은 두 가지만 빼면 equals와 같다. 이는 단순 동치성 비교에 더해 순서까지 비교할 수 있으며, 제네릭하다. 그리고 이를 구현한 객체들은 손쉽게 정렬, 검색, 등 수많은 제네릭 알고리즘과 컬렉션의 힘을 누릴 수 있다. 알파벳, 숫자, 연대 같이 순서가 명d확한 값 클래스를 작성한다면 반드시 이를 구현하자.

```java
public interface Comparable<T> {
  int compareTo(T t);
}
```

그리고 이 메서드의 일반 규약은 equals의 규약과 비슷하다.

이 객체와 주어진 객체의 순서를 비교한다. 이 객체가 주어진 객체보다 작으면 음의 정수, 같으면 0, 크면 양의 정수를 반환한다. 비교할 수없으면 ClassCastException을 던진다.

Comparable을 구현한 클래스는

- 모든 x, y에 대해 sgn(x.compareTo(y)) == -sgn(y.compareTo(x))여야 한다.
- 추이성을 보장해야 한다. 즉, x.compareTo(y) > 0 이고 y.compareTo(z) > 0 이면 x.compareTo(z) > 0 이다.
- 모든 z에 대해 x.compareTo(y) == 0 이면 sgn(x.compareTo(z)) == sgn(y.compareTo(z))다.
- 필수는 아니지만 이 권고는 꼭 지키는 것이 좋다. (x.compareTo(y) == 0) == (x.equals(y)) 여야 한다. 만약 이것이 지켜지지 않으면 그 사실을  다음과 같이 명시해야 한다. "주의: 이 클래스의 순서는 equals 메서드와 일관되지 않다."

equals와 굉장히 유사해보인다. 그래서 주의사항도 똑같다. 기존 클래스를 확장한 구체 클래스에서 새로운 값 컴포넌트를 추가하면 규약을 지킬 방법이 없다. 그리고 우회법도 같다.

compareTo 메서드에서 정수 기본 타입 필드를 비교할 때 관계연산자 <와 >를 사용하는 방식은 거추장스러우니, 박싱된 기본 타입 클래스들에 새로 추가된 정적메서드 compare을 이용하자. `return String.CASE_INSENSITIVE_ORDER.compare(this.s, object.s);`과 같이 말이다. 만약 여러개의 필드를 검사해야하면 당연 핵심적인 필드부터 비교하면 된다.

자바 8에서는 Comparator 인터페이스가 일련의 비교자 생성 메서드와 팀을 꾸려 연쇄 방식으로 비교자를 생성할 수 있게 되어 연쇄적으로 구현할 때 멋지게 활용하 수 있다. 되게 간결하지만, 약간의 성능저하가 뒤따른다. 대충 10%정도.. 나중에 필요하면 찾아서 적용하자.