# Method

메서드를 설계할 때 주의할 점을 살펴보자.



### 매개변수가 유효한지 검사하라

메서드와 생성자 대부분은 입력 매개변수의 값이 특정 조건을 만족하기를 바란다. 예컨대 인덱스 값은 음수이면 안되며, 객체 참조는 null이 아니어야 한다는 식이다.

이런 제약은 반드시 문서화해야 하며 메서드 몸체가 시작되기 전에 검사해야 한다. 이는 "오류는 가능한 빨리 잡아야 한다"는 일반원칙의 한 사례이기도 하다. 오류를 발생한 즉시 잡지 못하면, 오류를 감지하기 어려워지고 오류의 발생 지점을 찾기 어려워진다.

메서드 몸체가 실행되기 전에 매개변수를 확인한다면 잘못된 값이 넘어왔을 때 즉각적이고 깔끔한 방식으로 예외를 던질 수 있다. 제일 나쁜 상황은 감지못하고 메서드는 제대로 실행되고 그 결과를 이상한 상태로 만들어놓아 미래의 알 수 없는 시점에 이 메서드와는 관련없는 오류를 낼 때다.

public과 protected 메서드는 매개변수 값이 잘못됐을 때 던지는 예외를 문서화해야 한다.(@throws 자바독 태그를 사용하면 된다.) 보통은 `IllegalArgumentException`, `IndexOutOfBoundsException`, `NullPointerExcetion`중 하나가 될 것이다. 다음은 전형적인 예이다.

```java
/*
* (현재 값 mod m) 값으르 반환한다. 이 메서드
* 항상 음이 아닌 BigInteger를 반환한다는 점에서 remainder 메서드와 다르다.
* 
* @param m 계수(양수여야 한다.)
* @return 현재 값 mod m
* @throws ArithmeticException m이 0보다 작거나 같으면 발생한다.
*/
public BigInteger mod(BigInteger m) {
  if(m.signum() <= 0)
    throw new ArithmeticException("계수(m)는 양수여야 합니다. " + m);
  ... // 계산수행
}
```

이 메서드는 m이 null이면 m.signum()호출 때 널포인터 예외를 던진다. 하지만 메서드 설명에는 어디에도 없다. 그 이유는 BigInteger 클래스 수준에서 기술했기 때문이다. 클래스 수준 주석은 크 클래스의 모든 public 메서드에 적용되므로 각 메서드에 일일이 기술하는 것보다 훨씬 깔끔하 방법이다. 애너테이션을 사용해 알려줄 수 있지만 표준적인 방법은 아니다.

자바 7에 추가된 <u>java.util.Objects.requireNonNull 메서드는 유연하고 사용하기도 편하니, 더 이상 null검사를 수동으로 하지 않아도 된다.</u>

```java
this.strategy = Objects.requireNonNull(strategy, "전략");
```

반환값은 그냥 무시하고 필요한 곳 어디서든 순수한 null 검사 목적으로 사용해도 된다.



공개되지 않은 메서드라면 패키지 제작자인 우리가 메서가 호출되는 상황을 통제할 수 있다. 오직 유효한 값만이 메서드에 넘겨지리라는 것을 우리가 보증할 수 있고 그렇게 해야 한다. public이 아닌 메서드라면 단언문 assert를 사용해 매개변수 유효성을 검증할 수 있다.

```java
private static void sort(long a[], int offset, int length) {
  assert a != null;
  assert offset >= 0 && offset <= a.length;
  assert length >= 0 && length <= a.length - offset;
  ... // 계산 수행
}
```

단언문은 무조건 참이라고 여기고 실패하면 AssertionError를 던진다. 

메서드가 직접 사용하지는 않으나 나중에 쓰기 위해 저장하는 매개변수는 특히 더 신경써서 검사해야 한다.나중에 돌려받은 List를 사용하려 할때  Null 예외가 발생하면 추적하기 상당히 곤란해지기 때문이다.



### 적시에 방어적 복사본을 만들라

자바는 안전한 언어다. 메모리 충돌 오류에서도 안전하며 자바 클래스는 시스템의 다른 부분에서 무슨 짓을 하든 그 불변식이 지켜진다. 하지만 아무리 자바라 해도 다른 클래스로부터의 침범을 아무런 노력 없이 다 막을 수 있는 건 아니다. 그러니 <u>클라이언트가 우리의 불변식을 깨뜨리려 혈안이 되어 있다고 가정하고 방어적으로 프로그래밍해야 한다.</u> 실제로 보안을 뚫으려는 시도는 늘고 있다.

어떤 객체든 그 객체의 허락 없이는 외부에서 내부를 수정하는 일은 불가능 하다. 하지만 주의를 기울이지 않으면 자기도 모르게 내부를 수정하도록 허락하는 경우가 생긴다.

자바의 Date 클래스는 낡은 API이며, 문제를 안고 있다. 이를 이용하다간 잘못하면 다른 클래스의 내부까지 수정이 가능하다. Date처럼 가변인 낡은 값 타입을 이용하던 시절이 길어서 여전히 많은 API와 내부 구현에 그 잔재가 남아 있다. 따라서 외부 공격으로부터 인스턴스의 내부를 보호하려면 <u>생성자에서 받은 가변 매개변수를 각각 방어적으로 복사(defensive copy)해야 한다.</u> 그런 다음 인스턴스 안에서는 원본이 아닌 복사본을 사용한다.

특히 Date클래스 같은 경우는 다음과 같이 작성할 경우

```java
public Period(Date start, Date end) {
  if (start.compareTo(end) > 0)
    throw new IllegalArgumentException("[ERROR]")
  this.start = start;
  this.end = end;
}
```

안전해 보일지 몰라도, 다음과 같은 코드면 어렵지 않게 부술 수 있다.

```java
Date start = new Date();
Date end = new Date();
Period p = new Period(start, end);
end.setYear(78); // p의 내부를 수정했다.
```

따라서 다음과 같이 사용해야 한다.

```java
public Period(Date start, Date end) {
  this.start = new Date(start.getTime());
  this.end = new Date(end.getTime());
  if (start.compareTo(end) > 0)
    throw new IllegalArgumentException("[ERROR]")
}
```

순서가 이상할지 몰라도 반드시 이렇게 작성해야만 한다. 멀티스레딩 환경이라면 원본 객체의 유효성을 검사한 후 복사본을 만드는 그 찰나의 취약한 순간에 다른 스레드가 원본 객체를 수정할 위험이 있기 때문이다. 따라서 수행하기전 먼저 유효성 검사를 실행하면 이런 위험에서 해방될 수 있다. (참고로 보안 커뮤니티에선 이 찰나의 공격을 TOCTOU공격이라 한다.)

방어적 복사에 Date의 clone메서드를 사용하지 않은 점에도 주목하자.Date는 final이 아니므로 clone이 Date가 정의한 게 아닐 수 있다. 즉, clone이 악의를 가진 하위 클래스의 인스턴스를 반환할 수도 있다. 이렇게 되면 공격자에게 Period 인스턴스 자체를 송두리째 맡기는 꼴이 된다. 따라서 이를 막기위해선 <u>매개변수가 제 3자에 의해 확장될 수 있는 타입이라면 clone을 사용해서는 안 된다.</u>

생성자를 수정하면 앞서의 공격은 막아낼 수 있지만 Period 인스턴스는 아직도 변경 가능하다. 접근자 메서드가 내부의 가변 정보를 직접 드러내기 때문이다. 예를 들면 다음과 같은 공격에 당할 수 있다.

```java
Date start = new Date();
Date end = new Date();
Period p = new Period(start, end);
p.end().setYear(78); // p의 내부가 변경되었다.
```

이를 막아내기 위해 단순한 접근자가 <u>가변 필드의 방어적 복사본을 반환하면 된다.</u>

```java
public Date start(){
  return new Date(start.getTime());
}
public Date end(){
  return new Date(end.getTime());
}
```

이렇게 갖추고 나면 Period는 완벽한 불변으로 거듭난다. 아무리 악의적인 혹은 부주의한 프로그래머라도 시작 시각이 종료 시각보다 나중일 수 없다는 불변식을 위배할 방법은 없다. (언어 외적 수단을 제외하곤) 이젠 모든 필드가 객체 안에 완벽하게 캡슐화되었다.

생성자와 달리 접근자 메서드에서는 방어적 복사에 clone을 사용해도 된다. Period가 가지고 있는 Date 객체는 java.util.Date임이 확실하기 때문이다. (신뢰할 수 있는 클래스이다.) 그렇다 하더라도 clone의 재정의는 주의할점이 많기에 일반적으로 생성자나 정적 팩터리를 쓰는 게 좋다.

매개변수를 방어적으로 복사하는 목적이 불변 객체를 만들기 위해서만은 아니다. 클라이언트가 제공한 객체의 참조를 내부의 자료구조에 보관해야 할 때면 항시 그 객체가 잠재적으로 변경될 수 있는지를 생각해야 한다. 변경될 수 있는 객체라면 넘겨 받고 임의로 변경되어도 그 클래스가 문제없이 동작할지를 따져보자.

그리고 Period예제일 경우 자바 8이상부턴 Instant(혹은 LocalDateTime이나 ZonedDateTime)를 사용하라. 혹여라도 복사 비용이 너무 크거나 신뢰할 수 있는 클라이언트라면 방어적 복사를 수행하는 대신 해당 구성요소를 수정했을 때의 책임이 클라이언트에 있음을 문서에 명시하도록 하자.



### 메서드 시그니처를 신중히 설계하라

<u>메서드 이름을 신중히 짓자.</u> 당연히 항상 표준 명명 규칙을 따라야 한다. 조금 더 자세한 명명 규칙은 추후에 소개하기로 한다. 같은 패키지에 속한 다른 이름들과는 일관되게 지어야 하고, 개발자 커뮤니티에서 널리 받아들여지는 이름을 사용하는 것이 좋다. 긴 이름을 피하고, 애매하면 자바 라이브러리의 API 가이드를 참조하라. 워낙 방대해서 일관되지 않은 이름도 제법 있지만 대부분은 납득할 만한 수준이다.

<u>편의 메서드를 너무 많이 만들지 말자.</u> 모든 메서드는 각각 자신의 소임을 다해야 한다. 메서드가 너무 많은 클래스는 익히고, 사용하고, 문서화하고, 테스트하고, 유지보수하기 어렵다. 인터페이스도 마찬가지다. 아주 자주 쓰일 경우에만 별도의 약칭 메서드를 두기 바란다. 확신이 서지 않으면 만들지 말자.

<u>매개변수 목록은 짧게 유지하자.</u> 4개 이하가 좋다. 일단 4개가 넘어가면 매개변수를 전부 기억하기가 쉽지 않다. 만약 이 제한을 넘는 메서드가 많다면 프로그래머들은 API문서를 옆에 끼고 개발해야 한다. 특히 같은 타입의 매개변수 여러 개가 연달아 나오는 경우는 정말 해롭다. 순서를 바꿔도 실행되고, 기억하기도 어렵다.

과하게 긴 매개변수 목록을 짧게 줄여주는 기술 세 가지가 있다.

- 여러 메서드로 쪼갠다. 쪼개진 메서드 각각은 원래 매개변수 목록의 부분집합을 받는다. 잘못하면 메서드가 너무 많아질 수 있지만, 서로 영향을 주는 부분이 줄어들어 오히려 메서드 수를 줄여주는 효과도 있다.
- 매개변수 여러 개를 묶어주는 도우미 클래스를 만드는 것이다. 일반적으로 이런 도우미 클래스는 정적 멤버 클래스로 둔다. 예를 들어 카드게임을 클래스로 만든다고 해보자. 그러면 메서드를 호출할 때 카드의 숫자와 무늬를 뜻하는 두 매개변수를 항상 같은 순서로 전달할 것이다. 따라서 이 둘을 묶는 도우미 클래스를 만들어 하나의 매개변수로 주고받으면 API는 물론 클래스 내부 구현도 깔끔해질 것이다.
- 빌더 패턴을 메서드 호출에 응용하자.  이 기법은 매개변수가 많을 때, 특히 그중 일부는 생략해도 괜찮을 때 도움이 된다. 먼저 모든 매개변수를 하나로 추상화한 객체를 정의하고, 클라이언트에서 이 객체의 세터 메서드를 호출해 필요한 값을 설정하게 하는 것이다. 다 설정한 다음 execute 메서드를 호출해 앞서 설정한 매개변수들의 유효성을 검사하고 설정완료된 객체를 넘겨 수행한다.
- 매개변수의 타입으로는 클래스보다 인터페이스가 더 낫다. 매개변수로 적합한 인터페이스가 있다면 그 인터페이스를 직접 사용하자. 예를 들어 메서드에 HashMap을 넘길 일은 전혀 없다. 대신 Map을 사용하자. 인터페이스 대신 클래스를 사용하면 특정 구현체만 사용하도록 제한하는 꼴이며, 혹시라도 다른 형태라면 옮겨 담느라 비싼 복사 비용을 치러야 한다.
- boolean보다는 원소 2개짜리 열거 타입이 낫다. 메서드 이름상 boolean을 받아야 의미가 더 명확할 때만은 예외다.



### 다중정의는 신중히 사용하라

다중정의가 되면 어느 메서드를 호출할지는 <u>컴파일타임에 정해진다.</u> 재정의한 메서드는 동적으로 선택이 되지만, 다중정의한 메서드는 정적으로 선택이 된다. 그래서 다중정의는 직관에서 벗어날 가능성이 있다. 따라서 혼동을 일으키는 상황은 피하는게 좋다. <u>안정적이고 보수적으로 가려면 매개변수 수가 같은 다중정의는 만들지 말자.</u> 

ObjectOutputStream 클래스를 살펴보면 write메서드가 있다. 근데 다중정의가 아닌 타입별로 다른 이름을 지어주는 방법을 택했다. writeBoolean, writeInt, writeLong 이런 식이다. read메서드와 짝맞추기도 좋고 오해의 여지도 없다.

한편, 생성자는 이름을 다르게 지을 수 없으니 두 번째 생성자부터는 무조건 다중정의가 된다. 하지만 정적 팩터리라는 대안을 활용할 수 있는 경우가 많다. 또한 생성자는 재정의할 수 없으니 혼용될 걱정은 안해도 된다. 만약 매개변수가 많더라도, 하나이상이 근본적으로 다르다면 괜찮다. 근본적으로 다르다는 것은 두 타입이 서로 형변환이 불가능하다는 뜻이다.

자바 4까지는 모든 기본 타입이 모든 참조 타입과 근본적으로 달랐지만, 자바 5에서 오토박싱이 도입되면서 평화롭던 시대가 막을 내렸다. 다음을 보자.

```java
public class SetList {
  public static void main(String[] args) {
    Set<Integer> set = new TreeSet<>();
    List<Integer> list = new ArrayList<>();
    
    for (int i = -3; i < 3; i++) {
      set.add(i);
      list.add(i);
    }
    
    for (int i = 0; i < 3; i ++) {
      set.remove(i);
      list.remove(i);
    }
    System.out.println(set + " " + list);
  }
}
```

결과를 맞출 수 있는 사람은 드물것이다. 직접 돌려보면 알겠지만 결과는 `[-3, -2, -1] [-2, 0, 2]` 가 나온다. 대체 무슨일일까..

set.remove(i)의 시그니처는 remove(Object)다. 다중정의된 다른 메서드가 없으니 기대한 대로 동작하여 제대로 동작한다.

한편, list.remove(i)는 다중정의된 remove(int index)를 선택한다. 따라서 위의 결과가 나오는 것이다. 이 문제는  Integer.valueOf를 이용해 Integer로 변환한 후 전달하면 원래 기대한 값이 나온다.

이보다 예시가 복잡해지면 다중정의 메서드에서 어떤 것이 선택될지 구분하기는 더 어려워진다. 다중정의된 메서드 중 하나를 선택하는 규칙은 매우 복잡하며, 자바가 버전업될수록 실시간으로 더 복잡해지는 중이다. 자바 라이브러리는 이 아이템의 정신을 지켜내려 애쓰고 있지만, 실패한 클래스도 몇 개있다. String 클래스의 valueOf(char[])과 valueOf(Object)는 같은 객체를 건네더라도 전혀 다른 일을 수행한다. 따라서 다중정의는 피하는 것이 좋다.



### 가변인수는 신중히 사용하라

이는 키워드만 남겨두고, 아직 사용한일이 없기에 필요하면 찾아서 보기로 한다.



### null이 아닌, 빈 컬렉션이나 배열을 반환하라.

흔히 볼 수 있는 메서드중, 컬렉션이 비었으면 null을 반환하는 것이다. 특정한 뭐가 없다고해서 null을 반환할 필요는 없다. 만약 null을 반환한다면, 클라이언트는 이 null 상황을 처리하는 코드를 추가로 작성해야 한다. 객체가 없다고 null을 반환한다면 클라이언트는 방어코드를 작성해줘야 한다. 근데 이 객체가 0개일 가능성이 거의 없다면 수년 뒤에야 오류가 발생하기도 한다. 다음은 빈컬렉션과 배열을 굳이 새로 할당하지 않고도 반환할 수 있다. 다음은 빈 컬렉션을 반환하는 전형적인 코드이고, 대부분은 이렇게 하면 된다.

```java
public List<Cheese> getCheeses() {
  return new ArrayList<>(cheesesInStock);
}
```

아주 가끔, 사용 패턴에 따라 빈 컬렉션 할당이 성능을 눈에 뜨게 떨어뜨릴 수도 있다. 해법은 그냥 매번 똑같은 빈 '불변' 컬렉션을 반환하는 것이다. 불변 객체는 자유롭게 공유해도 안전하므로 그렇게 하면 된다. 단, 최적화에만 해당하니 꼭 필요할 때만 사용하자. 쓰더라도 실제로 성능이 개선되는지 확인도 하자.

배열을 반환하더라도 길이가 0인 배열을 반환하자. 참고로 길이가 0인 배열은 모두 불변이므로 이를 미리 선언해서 반환해도 된다. 다만 성능 개선목적으로 미리 선언하지는 말자. 오히려 성능이 떨어진다는 연구결과도 있다.



### 옵셔널 반환은 신중히 하라

자바 8 전에는 메서드가 특정 조건에서 값을 반환할 수 없을 때 취할수 있는 선택지가 두 가지 있었다. 예외를 던지거나, null을 반환하는 것이다. 두 방법 모두 허점이 있다. 예외는 진짜 예외적인 상황에서만 사용해야 하며, 예외를 생성할 때 스택 추적 전체를 캡처하므로 비용도 만만치 않다. null도 당연히 문제가 많다. 너무 많이 언급했으므로 생략한다. 어찌됐든 자바 8로 올라가면서 또 하나의 선택지가 생겼다. `Optional<T>` 이다. null아닌 T 타입 참조를 하나 담거나, 혹은 아무것도 담지 않을 수 있다. 아무것도 안담았을 땐 비었다 라고 말한다. 그리고 옵셔널은 원소를 최대 1개 가질 수 있는 '불변' 컬렉션이다. 확실히 옵셔널을 반환하면 유연하고 사용하기 쉬우며, null을 반환하는 메서드보다 오류 가능성이 작다. 그리고 당연하게도 옵셔널을 반환하는 메서드는 절대로 null을 반환하지 말자.

근데 null을 반환하거나 예외를 던지는 대신 옵셔널 반환을 선택해야 하는 기준은 무엇일까? 먼저 반환 값이 없을 수도 있음을 API사용자에게 명확히 알려준다. 클라이언트가 대처할 수 있도록 해준다.

비슷하게 옵셔널을 반환한다면 클라이언트는 값을 받지 못했을 때 취할 행동을 선택해야 한다. 그중 하나는 기본값을 설정하는 방법이다.

```java
String lastWordInLexicon = max(words).orElse("단어 없음...");
```

또는 상황에 맞는 예외를 던질 수 있다. 실졔 예외가 아니라 예외 팩터리를 건넨 것에 주목하자. 예외가 발생하지 않으면 예외 생성비용은 들지 않는다.

```java
Toy myToy = max(toys).orElseThrow(TemperTantrumException::new);
```

항상 값이 채워져 있다고 확신하면 그냥 곧바로 꺼내도 된다. 다만 잘못 판단하면 예외가 발생할 것이다.

가끔 기본값을 설정하는 비용이 커서 부담이 될 수 있다. 혹은 filter, map, flatMap, ifPresent 메서드도 대비되어 있다. 여전히 모르겠다면 isPresnt 메서드를 보자. 옵셔널이 채워져있으면 true, 비면 false를 반환한다. 하지만 앞서 설명한 방법으로 가능하다면 그렇게 해야 더 짧고 명확하고 용법에 맞는 코드가 된다.

스트림을 사용한다면 옵셔널들을 스트림으로 받아서 다음과 같이 구현이 가능하다.

```java
streamOfOptionals
.filter(Optional::isPresent)
  .map(Optional::get)
```

자바 9에는 더 편하게 구현이 되도록 바꼈지만 8까지만으로 일단 넘어간다.



반환값으로 옵셔널을 사용한다고 해서 무조건 득이 되는 건 아니다. 예를 들어, <u>컬렉션, 스트림, 배열, 옵셔널 같은 컨테이너 타입은 옵셔널로 감싸면 안된다.</u> 빈 컨테이너를 반환하는 것이 낫다. 그렇다면 어떤 경우에 메서드 반환 타입을 이렇게 하는 것이 좋을까?

기본 규칙은 결과가 없을 수 있으며, 클라이언트가 이 상황을 특별하게 처리해야 한다면 `Optional<T>`를 반환한다. 당연히 대가는 따른다. 새로 할당해야 하는 객체이므로 성능은 낮아지기 마련이다. 심지어 기본 타입보다 한겹 더 감싸야 하므로 더 무거울 수 밖에 없다. 그래서 자바 설계자는 OptionalInt와 같이 전용 <u>옵셔널 클래스들도 준비했으니 박싱된 기본 타입을 담은 옵셔널을 반환하는 일은 없도록 하자.</u> 지금까지 옵셔널을 반환하고 반환된 옵셔널을 처리하는 이야기만 했다. 다른 쓰임은 적절하지 않은 경우가 태반이라 설명에 담지 않는다.



### 공개된 API 요소에는 항상 문서화 주석을 작성하라.

작성하는 자세한 방법은 따로 추가하는 것이 좋을 듯하여 여기서는 생략한다.

