# Class and Interface



### 클래스와 멤버의 접근 권한을 최소화하라

어설프게 설계된 컴포넌트와 잘 설계된 컴포넌트의 가장 큰 차이는 바로 클래스 내부 데이터와 구현 정보를 외부 컴포넌트로부터 얼마나 잘 숨겼느냐다. 잘 설계된 컴포넌트는 모든 내부 구현을 완벽히 숨겨, 구현과 API를 깔끔히 분리한다.

정보 은닉의 장점은 정말 많다. 그리고 그 장점을 구체적으로 알아보자.

- 시스템 개발 속도를 높인다. 여러 컴포넌트를 병렬로 개발할 수 있기 때문이다.
- 시스템 관리 비용을 낮춘다. 각 컴포넌트를 더 빨리 파악하여 디버깅할 수 있고, 다른 컴포넌트로 교체하는 부담도 적기 때문이다.
- 이 자체가 성능을 높여주진 않지만, 성능 최적화에 도움을 준다. 다른 컴포넌트에 영향을 주지 않고 해당 컴포넌트만 최적화할 수 있기 때문이다.
- 소프트웨어 재사용성을 높인다.
- 큰 시스템을 제작하는 난이도를 낮춰준다.

자바는 정보 은닉을 위한 다양한 장치를 제공한다. 그중 접근 제어자와 선언된 위치가 핵심이다. 기본 원칙은 간단하다. <u>모든 클래스와 멤버의 접근성을 가능한 한 좁혀야 한다.</u> 톱레벨 클래스와 인터페이스에 부여할 수 있는 접근 수준은 package-private와 public 두 가지다. public으로 선언하면 공개 API가 되므로 하위 호환을 위해 영원히 관리해줘야만 한다. 따라서 외부에서 쓸 이유가 없다면 package-private로 선언하자.

클래스의 공개 API를 세심히 설계한 후, 그 외의 모든 멤버는 private으로 만들자. 그런 다음 오직 같은 패키지의 다른 클래스가 접근해야 하는 멤버에 한하여 private를 제거해 package-private으로 풀어주자. 만약 public 클래스에서 멤버의 접근 수준을 package-private에서 protected로 바꾸는 순간 그 멤버에 접근할 수 있는 대상 범위가 엄청나게 넓어진다. public의 protected 멤버는 공개 API이므로 영원히 지원돼야 한다. 따라서 이부터는 적으면 적을수록 좋다.

<u>public 클래스의 인스턴스 필드는 되도록 public이 아니어야 한다.</u> 필드가 가변 객체를 참조하거나, final이 아닌 인스턴스 필드를 public으로 선언하면 그 필드에 담을 수 있는 값을 제한할 힘을 잃게 된다.



### public 클래스에서는 public 필드가 아닌 접근자 메서드를 사용하라

변수들은 public이아닌 private으로 한 후, 게더와 세터를 통해 가져오는게 맞다. 하지만 가끔 <u>package-private 클래스 혹은 private 중첩 클래스라면 데이터 필드를 노출한다 해도 하등의 문제가 없다.</u> 



### 변경 가능성을 최소화하라

불변 클래스란 간단히 말해 그 인스턴스의 내부 값을 수정할 수 없는 클래스다. 불변 인스턴스에 간직된 정보는 고정되어 객체가 파괴되는 순간까지 절대 달라지지 않는다. String과 같은 클래스를 말한다. 불변으로 설계한 데는 그럴만한 이유가 있다. 불변 클래스는 가변 클래스보다 설계하고 구현하고 사용하기 쉬우며, 오류가 생길 여지도 적고 훨씬 안전하다. 불변으로 만들려면 다음 다섯 가지 규칙을 따르면 된다.

- 상태를 변경하는 메서드를 제공하지 않는다.
- 클래스를 확장할 수 없도록 한다. 상속을 막는 대표적인 방법으로 클래스를 final로 선언하는 것이 있지만, 다른 방법도 있다.
- 모든 필드를 final로 선언한다. final이라고 하면 설계자의 의도까지 명확히 전달된다.
- 모든 필드를 private로 선언한다. 직접 접근해 수정하는 일을 막아준다.
- 자신 외에는 내부의 가변 컴포넌트에 접근할 수 없도록 한다. 클래스에 가변 객체를 참조하는 필드가 하나라도 있다면 클라이언트에서 그 객체의 참조를 얻을 수 없도록 해야 한다. 이런 필드는 절대 클라이언트가 제공한 객체 참조를 가리키게 해서는 안된다. 접근자 메서드도 그 필드를 방어적 복사로 수행해야 한다. 하지만 사실 방어적 복사도 필요 없게 만드는 것이 좋다.

불변 객체는 근본적으로 스레드 안전하여 따로 동기화할 필요 없다. 여러 스레드가 동시에 사용해도 절대 훼손되지 않는다. 그리고 안심하고 공유할 수도 있다. 따라서 불변 클래스라면 한번 만든 인스턴스를 최대한 재활용하기를 권한다.

그리고 불변 클래스는 자주 사용되는 인스턴스를 캐싱하여 같은 인스턴스를 중복 생성하지 않게 해주는 정적 팩터리를 제공할 수 있다. 이렇게 하면, 메모리 사용량과 가비지 컬렉션 비용이 줄어든다.

<u>불변 객체는 자유롭게 공유할 수 있음은 물론, 불변 객체끼리는 내부 데이터를 공유할 수 있다.</u> 

불변 클래스를 만드는 설계 방법 몇가지를 알아보자. 불변임을 보장하려면 자신을 상속하지 못하게 해야한다. final로 만드는 방법도 있지만 더 유연한 방법이 있다. 모든 생성자를 private혹은 package-private으로 만들고 public 정적 팩터리를 제공하는 방법이다. 구체적인 예를 보자.

```java
public class Complex {
  private final double re;
  private final double im;
  
  private Complex(double re, double im) {
    this.re = re;
    this.im = im;
  }
  
  public static Complex valueOf(double re, double im) {
    return new Complex(re, im);
  }
}
```

<u>이 방식이 최선일 때가 많다.</u> 그리고 사실상 이 불변 객체는 final이다. public이나 protected 생성자가 없으니 다른 패키지에서는 이 클래스를 확장하는게 불가능하기 때문이다. 정적 팩터리 방식은 다수의 구현 클래스를 활용한 유연성을 제공한다. 그리고 다음 릴리스에서 객체 캐싱 기능을 추가해 성능을 끌어올릴 수도 있다.

그리고 <u>단순한 값 객체는 항상 불변으로 만들자.</u> 생성자는 불변식 설정이 모두 완료된, 초기화가 완벽히 끝난 상태의 객체를 생성해야 한다. 확실한 이유가 없다면 <u>그 어떤 초기화 메서드도 public으로 제공해서는 안된다.</u> 객체를 재활용할 목적으로 상태를 다시 초기화하는 메서드도 안된다.



### 상속보다는 컴포지션을 사용하라

상속은 코드를 재사용하는 강력한 수단이지만, 항상 최선은 아니다. 잘못 사용하면 오류를 내기 쉬운 소프트웨어를 만들게 된다. 상위 클래스와 하위 클래스를 모두 같은 프로그래머가 통제하는 패키지 안에서라면 상속도 안전한 방법이다. 확장할 목적으로 설계되었고 문서화도 잘된 클래스도 마찬가지로 안전하다. 하지만 그게 아니라면 위험하다. 참고로 인터페이스 상속과는 무관하다. 메서드 호출과 달리 상속은 캡슐화를 깨뜨린다. 하위 클래스에서 새로운 메서드를 추가할 때 문제가 된다. 메서드 재정의를 했을 땐 보안 구멍이 생길 수 있다. 그럼 새 메서드를 추가하는 것은? 이 역시 안전하지 않다. 다음 릴리스에서 똑같은 이름의 메서드가 나온다면, 그리고 반환타입이 다르다면 컴파일조차 안된다. 만약 같다하더라도 메서드를 재정의한 꼴이니 다시 앞선 문제가 나온다. 규약을 만족시키지 못할 가능성도 있고, 아무튼 하지마라.

다행히 모두 피해가는 묘안으로 컴포지션이 있다. 새로운 클래스를 만들고 private 필드로 기존 클래스의 인스턴스를 참조하게 하면 된다. 새클래스의 인스턴스 메서드들은 기존 클래스의 대응하는 메서드를 호출해 그 결과를 반환한다. 이 방식을 전달(forwarding)이라 하며, 새 클래스의 메서드들을 전달 메서드라고 부른다. 그 결과 새로운 클래스는 기존 클래스의 내부 구현 방식의 영향에서 벗어난다. 예시를 보자.

```java
// 래퍼 클래스
public class InstrumentedSet<E> extends ForwardingSet<E> {
  private int addCount = 0;
  
  public InstrumentedSet(Set<E> s) {
    super(s);
  }
  
  @Override
  public boolean add(E e) {
    addCount++;
    return super.add(e);
  }
  
  @Override public boolean addAll(Collection<? extendsE> c) {
    addCount += c.size();
    return super.addAll(c);
  }
}

// 재사용이 가능한 전달 클래스
public class ForwardingSet<E> implements Set<E> {
  private final Set<E> s;
  public ForwardingSet(Set<E> s) { this.s = s; }
  // set의 모든 메서드를 전달하는 메서드
}
```

래퍼 클래스는 단점이 거의 없다. 한 가지, 콜백 프레임워크와는 어울리지 않는다는 점만 주의하면 된다.

상속은 문제가 많다. 순수한 is-a 관계일 때만 써야한다. 하지만 그래도 안심할 수 없다. 상위 클래스가 상속을 고려하지 않았다면, 상위 클래스가 결함이 있다면 이 결함은 그대로 승계된다. 결함까지도. 그래도 상속하고 싶다면 그때 확인하자 어떻게 해야하는지를.



### 추상 클래스보다는 인터페이스를 우선하라

자바가 제공하는 다중 구현 메커니즘은 인터페이스와 추상 클래스, 이렇게 두가지다. 자바 8부턴 인터페이스도 디폴트 메서드를 제공할 수 있게 되어 이제는 두 메커니즘 모두 인스턴스 메서드를 구현 형태로 제공할 수 있다. 가장 큰 둘의 차이는 추상 클래스가 정의한 타입을 구현하는 클래스는 추상 클래스의 하위 클래스가 되어야 한다는 점이고, 단일 상속만 허용하니 커다란 제약이다.

기존 클래스에도 손쉽게 새로운 인터페이스를 구현해넣을 수 있다. 인터페이스가 요구하는 메서드를 추가하고, 클래스 선언에 implement s 구문만 추가하면 끝이다. 하지만 추상 클래스는 그렇지 않고 조상관계가 영 껄끄럽다. 인터페이스는 믹스인(mixin) 정의에 안성맞춤이다. 클래스가 구현할 수 있는 타입이 믹스인이다. 믹스인을 구현한 클래스에 원래의 '주된 타입' 외에도 특정 선택적 행위를 제공한다고 선언하는 효과를 준다. 예컨대 Comparable을 떠올리면 된다.

인터페이스로는 계층구조가 없는 타입 프레임워크를 만들 수 있다. 타입을 계층적으로 정의하면 수많은 개념을 구조적으로 잘 표현할 수 있지만, 현실에는 그렇지 않은게 많다. 가수와 작곡가 인터페이스가 있다고 가정해보자.

```java
public interface Singer {
  AudioClip sing(Song song);
}

public interface Songwriter {
  Song compose(int charPosition);
}
```

우리 주변엔 작곡도 하는 가수가 제법 있다. 이 코드처럼 타입을 인터페이스로 정의하면 가수 클래스가 Singer와 Songwriter 모두를 구현해도 전혀 문제되지 않는다. 심지어 모두를 확장하고 새로운 메서드까지 추가한 제 3의 인터페이스를 정의할 수도 있다.

```java
public interface SingerSongwriter extends Singer, Songwriter {
  AudioClip strum();
  void actSensitive();
}
```

이 정도의 유연성이 항상 필요하진 않지만, 이렇게 만들어둔 인터페이스가 결정적인 도움을 줄 수도 있다.

래퍼 클래스 관용구와 함께 사용하면 인터페이스는 기능을 향상시키는 안전하고 강력한 수단 된다. 타입을 추상 클래스로 정의해두면 그 타입에 기능을 추가하는 방법은 상속뿐이다.

인터페이스의 메서드 중 구현 방법이 명백한 것이 있다면, 그 구현을 디폴트 메서드로 제공해 프로그래머들의 일감을 덜어줄 수 있다. 그리고 디폴트 메서드를 제공할 때는 상속하려는 사람을 위한 설명을 @implSpec 자바독 태그를 붙여 문서화 해야한다.

디폴트 메서드에도 제약은 있다. 많은 인터페이스가 equals와 hashCode같은 Object의 메서드를 정의하고 있지만, 이들은 디폴트 메서드로 제공해서는 안 된다. 또한 인터페이스는 인스턴스 필드를 가질 수 없고 public이 아닌 정적 멤버도 가질 수 없다.(단 private 정적 메서드는 예외) 마지막으로, 우리가 만들지 않은 인터페이스에는 디폴트 메서드를 추가할 수 없다.

<u>관례상</u> 인터페이스 이름이 Interface라면 그 골격 구현 클래스의 이름은 AbstractInterface로 짓는다. 다른 적절한 언어가 있을 수 있었지만 이미 늦었다. 제대로 설계하면 프로그래머의 일을 상당히 덜어준다. 다음 코드는 완벽히 동작하는 List 구현체를 반환하는 정적 팩터리 메서드로, AbstractList 골격 구현으로 활용했다.

```java
static List<Integer> intArrayAsList(int[] a) {
  Objects.requireNonNull(a);
  
  return new AbstractList<Integer>() {
    @Override public Integer get(int i) {
      return a[i]; // 오토박싱
    }
    
    @Override public Integer set(int i, Integer val) {
      int oldVal = a[i];
      a[i] = val; // 오토언박싱
      return oldVal; // 오토박싱
    }
    
    @Override public int size() {
      return a.length();
    }
  };
}
```

골격 구현을 확장하는 것으로 인터페이스 구현이 거의 끝나지만, 꼭 이렇게 해야하는 것은 아니다. 구조상 골격 구현을 확장하지 못하는 처지라면 인터페이스를 통해 직접 구현해야 한다. 간단한 예로 Map.Entry 인터페이스를 살펴보자. getKey, getValue는 확실히 기반 메서드이며, 선택적으로 setValue도 포함할 수 있다. 이 인터페이스는 equals와 hashCode의 동작 방식도 정의해놨다. Object 메서드들은 디폴트 메서드로 제공해서는 안 되므로, 해당 메서드들은 모두 골격 구현 클래스에 구현한다.



### 인터페이스는 구현하는 쪽을 생각해 설계하라

인터페이스에 메서드를 추가하면 보통 컴파일 오류가 난다. 추가된 메서드가 우연히 기존 구현체에 이미 존재할 가능성은 아주 낮다. 자바8에 와서는 기존 인터페이스에 추가할 수 있도록 디폴트 메서드를 소개했지만, 위험이 사라진 것은 아니다.

디폴트 메서드를 선언하면, 그 인터페이스를 구현한 후 디폴트 메서드를 재정의하지 않은 모든 클래스에서 디폴트 구현이 쓰이게 된다. 이처럼 자바에도 기존 인터페이스에 메서드를 추가하는 길이 열렸지만 매끄럽게 연동되라는 보장은 없다. 실제로 디폴트 메서드 때문에 문제생기는 코드는 당연히 존재한다. 따라서 기존 인터페이스에 디폴트 메서드로 새 메서드를 추가하는 일은 꼭 필요한 경우가 아니면 피해야 한다.



### 인터페이스는 타입을 정의하는 용도로만 사용하라

인터페이스는 자신을 구현한 클래스의 인스턴스를 참조할 수 있는 타입 역할을 한다. 즉, 클래스가 어떤 인터페이스를 구현한다는 것은 자신의 인스턴스로 무엇을 할 수 있는지를 클라이언트에 얘기해주는 것이다. 인터페이스는 <u>오직 이 용도로만 사용해야 한다.</u>

이 지침에 맞지 않는 예로 상수 인터페이스가 존재한다. 메서드 없이 상수로만 가득 찬 인터페이스를 말한다. 즉 잘못 사용한 예다. 클래스 내부에서 사용하는 상수는 외부 인터페이스가 아니라 내부 구현에 해당한다. 따라서 상수 인터페이스를 구현하는 것은 내부 구현을 클래스의 <u>API로 노출하는 행위다.</u> 사용자에게 오히려 혼란을 주게되고, 더 심하게는 클라이언트 코드가 내부 구현에 해당하는 이 상수들에 종속되게 한다.

상수를 공개할 목적이라면 더 합당한 선택지 몇 가지 있다. 특정 클래스나 인터페이스와 강하게 연관된 상수라면 그 클래스나 인터페이스 자체에 추가해야 한다. Integer.MIN_VALUE가 그 예시이다. 그게 아나리면  열거 타입, 그게 아니라면 인스턴스화할 수 없는(private 생성자가 있음) 유틸리티 클래스를 담아 공개하자.



### 태그 달린 클래스보다는 클래스 계층구조를 활용하라

두 가지 이상의 의미를 표현할 수 있으며, 그중 현재 표현하는 의미를 태그 값으로 알려주는 클래스가 있다. 예를 들면 다음과 같은 코드이다.

```java
class Figure {
  enum Shape { RECTANGLE, CIRCLE };
  
  final Shape shape; // 태그 필드, 현재 모양을 나타낸다.
  
  double length;
  double width;
  // 필드가 사각형일 때만 쓰임,
  
  double radius;
  // 필드가 원일때만 쓰임
  
  double area() {
    switch(shape) {
        ...
    }
  }
}
```

이런 류의 클래스를 말한다. 태그 달린 클래스는 단점이 한가득이다. 쓸데없는 코드가 너무 많아지고, 여러 구현이 한 클래스에 혼합돼 있어서 가독성도 나쁘다. 실수할 여지도 많다 엉뚱한 필드를 초기화해도 , 새로운 의미를 추가할 때마다, 등 여러 문제가 많아질 수 있다.

다행히 훨씬 나은 대안으로 클래스 계층구조를 활용하는 서브타이핑이다. 태그 달린 클래스는 클래스 계층구조를 어설프게 흉내낸 아류일 뿐이다.

먼저 루트가 될 추상 클래스를 정의하고, 태그 값에 따라 동작이 달라지는 메서드들을 루트 클래스의 추상 메서드로 선언한다. 여기서는 area가 이런 메서드에 해당한다. 따라서 다음처럼 수정한다.

```java
abstract class Figure {
  abstract double area();
}

class Circle extends Figure {
  @Override
  double area() { ... }
}

class Rectangle extends Figure {
  @Override
  double area() { ... }
}
```

쓸데없는 내용을 모두 날리고 간결하고 명확해졌다. 살아 남은 필드들은 모두 final로 선언한다. 실수로 빼먹은 case 문 때문에 런타임 오류가 발생할 일도 없다.



### 멤버 클래스는 되도록 static으로 만들라

중첩 클래스(nested class)란 다른 클래스 안에 정의된 클래스를 말한다. 중첩 클래스는 자신을 감싼 바깥 클래스에서만 쓰여야 하며, 그 외의 쓰임새가 있다면 톱레벨 클래스로 만들어야 한다.

중첩 클래스의 종류는 정적 멤버 클래스, 멤버 클래스, 익명 클래스, 지역 클래스 이렇게 네 가지다. 이중 첫번째를 제외한 나머지는 내부 클래스(inner class)에 해당한다.

먼저 정적 멤버 클래스를 알아보자. 정적 멤버 클래스는 다른 클래스 안에 선언되고, 바깥 클래스의 private 멤버에도 접근할 수 있다는 점만 제외하고 일반 클래스와 똑같다. 정적 멤버 클래스는 다른 정적 멤버와 같은 규칙을 적용받는다. private으로 선언하면 바깥 클래스에서만 접근할 수 있는 식이다.

정적 멤버 클래스는 흔히 바깥 클래스와 함께 쓰일 때만 유용한 public 도우미 클래스로 쓰인다.

비정적 멤버 클래스는 어댑터를 정의할 때 자주 쓰인다. 즉, 어떤 클래스의 인스턴스를 감싸 마치 다른 클래스의 인스턴스처럼 보이게 하는 <u>뷰로 사용</u>하는 것이다. 예컨대 Map 인터페이스의 구현체들은 보통 (keySet, entrySet, values 메서드가 반환하는) 자신의 컬렉션 뷰를 구현할 때 비정적 멤버 클래스를 사용한다. 비슷하게, Set과 List 같은 다른 컬렉션 인터페이스 구현들도 자신의 반복자를 구현할 때 비정적 멤버 클래스를 주로 사용한다. 예를 들면 다음과 같다.

```java
public class MySet<E> extends AbstractSet<E> {
  ... //
  @Override public Iterator<E> iterator() {
     return new MyIterator();
  }
  
  private class MyIterator implements Iterator<E> {
    ...
  }
}
```

<u>멤버 클래스에서 바깥 인스턴스에 접근할 일이 없다면 무조건 static을 붙여서 정적 멤버 클래스로 만들자.</u> static을 생략하면 바깥 인스턴스로의 숨은 외부 참조를 갖게 된다. 하지만 이 참조를 저장하려면 시간과 공간이 소비되고, 가비지 컬렉션이 제 기능을 못할 수도 있다.

나머지는 나중에 알아보자.