# Programming Principle



이미 다른 공부에서 언급을 했었거나 누구에게 공유보단 개인적인 정리를 위함이라 평소에 습관처럼 해왔던 부분에 대해선 생략하였습니다.

### 다른 타입이 적절하다면 문자열 사용을 피하라

문자열은 텍스트를 표현하도록 설계되었고, 아주 잘 해내고 있다. 하지만 워낙 흔하고 잘 지원해주어 의도하지 않은 용도대로 쓰이는 경향이 있다. 이에 대해 알아보자.

문자열은 다른 값 타입을 대신하기에 적합하지 않다. 사뭇 자연스러워보이지만, 입력받을 데이터가 진짜 문자열일 때만 그렇게 하는게 좋다. 받은 데이터가 수치형이라면 int, float, BigInteger등 적당한 수치 타입으로 변환해야 한다. 문자열은 열거 타입을 대신하기에 적합하지 않으며 상수를 열거할 땐 열거 타입이 월등히 낫다.

문자열은 혼합 타입을 대신하기에 적합하지 않다.여러 요소가 혼합된 데이터를 하나의 문자열로 표현하는 것은 대체로 좋지 않은 생각이다 예를 들면 다음과 같은 코드말이다.

```java 
String compoundKey = className + "#" + i.next();
```

이는 단점이 많은 방식이다. 각 요소를 개별적으로 접근하려면 문자열을 파싱해야  해서 느리고, 귀찮고, 오류 가능성도 커진다. 절절한 equals, toString, compareTo 메서드를 제공할 수 없고 String이 제공하는 기능에만 의존해야 한다.



### 문자열 연결은 느리니 주의하라

문자열 연결 연산자  +는 여러 문자열을 하나로 합쳐주는 편리한 수단이다. 크기가 작고 고정된 객체의 문자열 표현일땐 괜찮지만, 본격적으로 사용하기 시작하면 성능 저하를 감내하기 어렵다. 문자열 연결 연산자로 문자열 n개를 잇는 시간은 $n^2$에 비례한다. 혹시 길어질것 같다면 StringBuilder를 사용하자.



### 객체는 인터페이스를 사용해 참조하라

적합한 인터페이스만 있다면 매개변수뿐 아니라 반환값, 변수, 필드를 전부, 인터페이스 타입으로 선언하라. 객체의 실제 클래스를 사용해야 할 상황은 '오직' 생성자로 생성할 때뿐이다. 예를 들어 다음은 Set 인터페이스를 구현한 LinkedHashSet변수를 선언하는 올바른 모습이다.

```java
Set<Son> sonSet = new LinkedHashSet<>();
```

다음은 나쁜 예이다. 클래스를 타입으로 사용했다.

```java
LinkedHashSet<Son> sonSet = new LinkedHashSet<>();
```

인터페이스를 타입으로 사용하는 습관을 길러두면 프로그램이 훨씬 유연해진다.

단, 주의할 점이 하나 있다. 원래의 클래스가 인터페이스의 일반 규약 이외의 특별한 기능을 제공하며, 주변 코드가 이 기능에 기대어 동작한다면 새로운 클래스도 반드시 같은 기능을 제공해야 한다.

적합한 인터페이스가 없다면 당연히 클래스로 참조해야 한다. String과 BigInteger 같은 값 클래스가 그렇다. 값 클래스를 여러 가지로 구현될 수 있다고 생각하고 설계하는 일은 거의 없다. 따라서 final인 경우가 많고 상응하는 인터페이스가 별도로 존재하는 경우가 드물다. 이런 값 클래스는 매개변수, 변수, 필드, 반환 타입으로 사용해도 무방하다.



### 리플렉션보다는 인터페이스를 사용하라

스프링을 배우고 나서 이부분은 재학습하기로 한다.

