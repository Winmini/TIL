# Strategy



템플릿 메서드 패턴은 부모 클래스에 변하지 않는 템플릿을 두고, 변하는 부분을 자식 클래스에 두어 상속을 사용해 문제를 해결했다.

전략 패턴은 변하지 않는 부분을 `Context`라는 곳에 두고 변하는 부분을 `Strategy` 라는 인터페이스를 만들고 해당 인터페이스를 구현하도록 해서 문제를 해결한다. 즉 상속에서 위임으로 문제를 해결하는 것이다.

만들어보자.

```java
@Slf4j
public class ContextV1 {

	private final Strategy strategy;

	public ContextV1(Strategy strategy){
		this.strategy = strategy;
	}

	public void execute() {
		long startTime = System.currentTimeMillis();

		strategy.call();

		long endTime = System.currentTimeMillis();
		long resultTime = endTime - startTime;
		log.info("resultTime={}", resultTime);
	}
}

```

이렇게 Context는 Strategy 인터페이스를 주입으로 받고, Strategy를 구현으로 해결하면 된다. 그럼 서로 의존 관계가 약해져서 어떤 코드를 수정하더라도 서로 신경쓰지 않을 수 있다.

그리고 잘생각해보면 이거 스프링 의존관계 주입에서 보는 모습이랑 비슷하다. 스프링 의존관계 주입에서 사용하는 패턴이 바로 이 전략 패턴이다.

그리고 strategy가 가진 call 메서드는 익명 내부클래스를 이용해도 되고, 새로 클래스로 정의해도 되고 만약 call메서드밖에 없다면 람다로 사용할수도 있다.



이 전략 패턴은 기본적으로 stratgey와 context를 사용할 때 실행 전에 조립을 해두고, 실행한다. 스프링으로 맨 처음 의존 주입을 통해 다 맺어두고 실행했던 것과 마찬가지 방법이다. 단점은 조립 이후에 전략을 변경하기가 번거롭다는 점이다. Context를 싱글톤으로 사용한다면 동시성 이슈도 고려해야 한다. 그래서 전략을 실시간으로 변경해야 한다면 그냥 Context를 하나 더 생성하고 다른 전략을 주입하는 것이 나을 수 있다.



만약 더 유연하게 전략 패턴을 사용하고 싶다면 어떻게 하면 좋을까?

전략 패턴을 생성자 주입이 아니라 파라미터 주입을 통해서 해결할 수도 있다. execute 메서드에 Strategy를 파라미터로 받으면 그때 그때 전략을 넣어서 수행할 수도 있다. 즉 선 조립후 실행에서 벗어날 수 있다. 그럼 실시간으로 바꾸면서 유연하게 사용할 수 있다. 다만 실행할 때마다 전략을 넣어주어야 하므로, 이게 싫으면 이게 번거로울 수 있다.



### 템플릿 콜백 패턴

프로그래밍에서 **콜백**이란 다른 코드의 인수로서 넘겨주는 실행 가능한 코드를 말한다. 콜백을 넘겨받는 코드는 이 콜백을 필요에 따라 즉시 실행하거나, 나중에 실행할 수도 있다.

쉽게 이야기하면 call(호출)은 되는데 코드를 넘겨준 곳 back(뒤)에서 실행된다는 뜻이다. Context에서 콜백은 `Strategy`이다. 클라이언트에서 직접 `Strategy`를 실행하는 것이 아니라 넘겨주고 뒤에서 실행되었다.



자바 언어에서의 콜백

- 자바 언어에서 실행 코드를 인수로 넘기려면 객체가 필요하다. 근데 자바 8부터는 람다를 사용할 수 있다.
- 자바 8 이전에는 보통 하나의 메서드를 가진 인터페이스를 구현하고, 주로 익명 내부 클래스를 이용했다.



스프링에서는 지금 사용한 방식의 전략 패턴을 템플릿 콜백 패턴이라 한다. `Context`가 템플릿 역할을 하고, `Strategy`부분이 콜백으로 넘어온다 생각하면 된다. 스프링 내부에서 이런 방식을 자주 사용하기 때문에, 스프링 안에서만 이렇게 부른다. 전략패턴에서 템플릿과 콜백이 강조된 패턴이라 생각하면 된다. 스프링에서 `JdbcTemplate`, `RestTemplate` 등 `XxxTemplate`과 같은 클래슬르 보면 이와 같은 패턴으로 만들어져 있다 생각하면 된다.



**결국..**

근데 진짜 최적화를 해도 결국 본질적으로 문제가 생기면 **원본코드**를 수정해야 한다. 개발자의 게으름에 대한 욕심은 끝이 없다. 이 문제를 해결하기 위해 만든 해결책으로 프록시라는 개념이 도입되었다. 프록시에 대해서 이해해보자.