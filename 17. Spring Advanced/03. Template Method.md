# Template Method



쓰레드 로컬까지 적용해도 여전히 문제가 있다. 기존 로직이 너무 더럽기 때문이다. 핵심기능보다 부가기능의 코드가 더 길어졌다. 나중에 더 많은 내용이 생긴다면, 핵심기능 코드는 나중에 찾기도 힘들 것이다.

그리고 클래스가 늘어날수록 모든 코드에 `try~catch`문을 작성하기도 힘들다. 이를 해결하는 방법을 생각해보자. 코드를 잘 보면 동일한 패턴이 있다.

이런 부분은 추상클래스로 해결할 수 있다.

```java
@Slf4j
public abstract class AbstractTemplate {

	public void execute(){
		long startTime = System.currentTimeMillis();

		call();

		long endTime = System.currentTimeMillis();
		long resultTime = endTime - startTime;
		log.info("resultTime={}", resultTime);
	}

	protected abstract void call();

}
```

이렇게 겹치는 부분을 감싸고, call을 추상메서드로 만든다. 그럼 이 클래스를 상속하여 call부분만 조정해주면, 중복이 없어질 수 있다.

좀 더 개선해보자. 이런 템플릿 메서드 패턴은 클래스를 계속 만들어야 하는 부분이 단점이다. 익명 내부 클래스를 이용하면 이런 단점도 보완할 수 있다.

```java
AbstractTemplate template1 = new AbstractTemplate() {
  @Override
  protected void call() {
    log.info("비즈니스 로직1 실행");
  }
 };
```

이렇게 선언하면서 할 수 있다.



#### 좋은 설계란?

좋은 설계란 다양한 정의가 있는데, 확실한건 내가 유지보수할 때 코드를 변경하게 될 때 자연스레 알게된다. 잘 설계해둔 코드라면, 기존의 코드들을 건드릴 일이 없을 것이다. 템플릿을 적용하면 템플릿 로직을 변경해도 사용하는 코드는 피해를 받지 않는다. 확실한건 더 좋은 설계로 바꿨기 때문에 가능한 것이다.



**문제점**

템플릿 메서드 패턴은 기본적으로 상속을 사용한다. 그래서 상속에서 오는 단점들을 안고 간다. 특히 자식 클래스가 부모 클래스와 컴파일 시점에 강하게 결합되어 있다. 근데 자식 클래스 입장에서는 부모 클래스의 기능을 전혀 사용하지 않는다. 그런데도 패턴을 위해 상속받는다.

자식 입장에서 부모 클래스의 기능을 전혀 사용하지 않음에도, 부모 클래스를 알아야 하며 이는 좋은 설계에서 벗어난다. 그리고 잘못된 의존관계를 가지고 있어서 부모 클래스를 수정하면, 자식 클래스에도 영향을 줄 수 있다.



**개선**

그래서 템플릿 메서드 패턴과 비슷한 역할을 하면서 상속의 단점을 제거할 수 있는 패턴이 전략 패턴이다.