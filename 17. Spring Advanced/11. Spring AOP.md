# Spring AOP



애플리케이션 로직은 크게 **핵심 기능**과 **부가 기능**으로 나눌 수 있다. 핵심 기능은 그 객체가 제공하는 고유의 기능이다. `OrderService` 객체라면 이 객체의 핵심 기능은 주문 로직이다. 부가 기능은 핵심 기능을 보조하기 위해 제공되는 기능이다. 예를 들어 로그 추적 로직, 트랜잭션 기능 등이 있다. 이러한 부가 기능은 단독으로 사용되지 않고, 핵심 기능과 함께 사용된다. 예를 들어 로구 추적 기능은 어떤 핵심 기능이 호출되었는지 로그를 남기기 위해 사용된다.

그리고 보통 부가 기능은 여러 클래스에 걸쳐서 함께 사용된다.



부가 기능 적용 문제가 있다.

적용을 하는 곳마다 코드를 추가해야한다. 부가 기능을 별도의 유틸리티 클래스로 만든다 해도 결국 호출하는 코드가 필요해진다. 그리고 단순한 호출이 아니라 `try catch` 문이라면 더욱 복잡해지고, 수정하는 작업도 매우 번거로워진다. 그래서 일반적인 OOP 방식으로는 해결이 어렵다.



### AOP 소개

AOP의 대표적인 구현으로  AspectJ 프레임워크가 있다. 물론 스프링도 AOP를 지원하지만 대부분 AspectJ의 문법을 차용하고 AspectJ가 제공하는 기능의 일부만 제공한다. AspectJ는 스스로를 다음과 같이 설명한다.

- 자바 프로그래밍 언어에 대한 완벽한 관점 지향 확장
- 횡단 관심사의 깔끔한 모듈화
  - 오류 검사 및 처리
  - 동기화
  - 성능 최적화(캐싱)
  - 모니터링 및 로깅



### AOP 적용 방식

AOP를 사용하면 핵심 기능과 부가 기능이 코드상 완전히 분리되어서 관리된다. 그렇다면 AOP를 사용할 때 부가 기능 로직은 어떤 방식으로 실제 로직에 추가될 수 있을까?

3가지 방법이 있다.

- 컴파일 시점
- 클래스 로딩 시점
- 런타임 시점(프록시)



**컴파일 시점**

`.java` 소스 코드를 컴파일러를 사용해서 `.class` 를 만드는 시점에 부가 기능 로직을 추가할 수 있다. 이때는 `AspectJ`가 제공하는 특별한 컴파일러를 사용해야 한다. 컴파일 된 `.class`를 디컴파일해보면 Aspect 관련 호출코드가 들어간다. AspectJ 컴파일러는 Aspect를 확인해서 해당 클래스가 적용 대상인지 확인하고, 적용 대상인 경우에 부가 기능 로직을 적용한다. 참고로 이렇게 원본 로직에 부가 기능 로직이 추가되는 것을 위빙(Weaving)이라고 한다.

단점으로 특별한 컴파일러도 필요하고 복잡하다. 그래서 잘 사용하지 않는다.



**클래스 로딩 시점**

자바를 실행하면 자바 언어는 `.class` 파일을 JVM 내부의 클래스 로더에 보관한다. 이 때 중간에서 `.class`파일을 조작한 다음 JVM에 올릴 수 있다. 자바 언어는 `.class`를 JVM에 저장하기 전에 조작할 수 있는 기능을 제공한다. 궁금하면 java Instrumentation을 찾아보자. 수 많은 모니터링 툴들이 이 방식을 사용하며 이 시점에 Aspect를 적용하는 것을 로드타임 위빙이라 한다.

단점으로 로드 타임 위빙은 자바를 실행할 때 특별한 옵션(`java -javaagent`)을 통해 클래스 로더 조작기를 지정해야 하는데, 이 부분이 번거롭고 운영하기 어렵다. 그래서 잘 사용하지 않는다. 



**런타임 시점**

런타임 시점은 컴파일도 다 끝나고, 컴파일 로더에 클래스도 다 올라가서 이미 자바가 실행되고 난 다음을 말한다. 자바의 메인메서드가 이미 실행된 다음이다. 따라서 자바 언어가 제공하는 범위 안에서 부가 기능을 적용해야 한다. 스프링과 같은 컨테이너의 도움과 프록시,DI, 빈 포스트 프로세서 같은 개념들을 동원해야 한다. 프록시를 사용하기 때문에 AOP 기능에 일부 제약이 있지만(final은 안되거나 생성자 문제 즉 오버라이드가 되어야 한다.), 복잡한 옵션이나 클래스 로더 조작기를 설정하지 않아도 된다. 스프링만 있으면 얼마든지 AOP를 적용할 수 있다.



**AOP 적용 위치**

적용 가능 지점(조인 포인트): 생성자, 필드 값 접근, static 메서드 접근, 메서드 실행

AspectJ를 사용하면 바이트 코드까지 조작이 가능하기 때문에 모든 지점에 다 적용할 수 있다.

- 프록시 방식을 사용하는 **스프링 AOP는 메서드 실행 지점에만 AOP를 적용**할 수 있다.
- 프록시는 메서드 오버라이딩 개념으로 동작하여 생성자나 static 메서드, 필드 값 접근 등에는 적용될 수 없다.
- 스프링 컨테이너가 관리하는 **스프링 빈에만 AOP를 적용**할 수 있다.

참고로 AspectJ의 문법을 차용하고 프록시 방식이며 AspectJ를 직접 사용하는 것이 아니다.



근데 스프링이 제공하는 AOP는 프록시를 사용하는데, AspectJ를 사용하면 더 복잡하고 더 다양한 기능을 사용할 수 있는데 왜 스프링 AOP를 사용할까?

AspectJ를 사용하려면 공부할 내용도 많고, 자바 관련 설정(특별한 컴파일러, AspectJ 전용 문법, 자바 실행 옵션)도 복잡하다. 반면에 스프링 AOP는 별도의 추가 자바 설정없이 편리하게 사용할 수 있고 이 것만 사용해도 대부분의 문제를 해결할 수 있다.



### AOP 용어 정리

**조인 포인트(Join Point)**

- 어드바이스가 적용될 수 있는 위치, 메서드 실행, 생성자 호출, 필드 값 접근 등 프로그램 실행 중 지점
- 추상적인 개념이며, AOP를 적용할 수 있는 모든 지점
- 스프링 AOP는 프록시 방식을 사용하므로 조인 포인트는 **항상 메서드 실행 지점으로 제한된다.**

**포인트 컷(Pointcut)**

- 조인 포인트 중에서 어드바이스가 적용될 위치를 선별하는 기능
- 주로 AspectJ 표현식을 사용해서 지정
- 프록시를 사용하는 스프링 AOP는 메서드 실행 지점만 포인트 컷으로 선별 가능

**타겟(Target)**

- 어드바이스를 받는 객체, 포인트 컷으로 결정

**어드바이스(Advice)**

- 부가 기능
- 특정 조인 포인트에서 Aspect에 의해 취해지는 조치
- Around, Before, After와 같은 다양한 종류의 어드바이스가 있음

**애스펙트(Aspect)**

- 어드바이스 + 포인트컷을 모듈화한 것
- `@Aspect`를 생각하면 된다.

**어드바이저(Advisor)**

- 하나의 어드바이스와 하나의 포인트 컷으로 구성
- 스프링 AOP에서만 사용되는 특별한 용어

**위빙(Weaving)**

- 포인트 컷으로 결정한 타겟의 조인 포인트에 어드바이스를 적용하는 것
- AOP 적용을 위해 애스펙트를 객체에 연결한 상태
  - 컴파일 타임
  - 로드 타임
  - 런타임

**AOP 프록시**

- AOP 기능을 구현하기 위해 만든 프록시 객체, 스프링에서 AOP 프록시는 JDK 동적프록시 또는 CGLIB프록시이다.