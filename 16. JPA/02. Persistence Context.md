# Persistence Context



JPA에서 가장 중요한 2가지를 말해보면,

- 객체와 관계형 데이터베이스 매핑하기 (ORM)
- **영속성 컨텍스트**

라고 할 수 있다.

먼저 엔티티 매니저 팩토리와 엔티티 매니저에 대해서 알아보자.

고객의 요청이 올 때마다 엔티티 매니저 팩토리에서 엔티티 매니저를 생성해서 고객마다 할당한다. 그리고 내부적으로 db 커넥션을 사용해서 db를 사용하게 된다.

근데 영속성 컨텍스트는 뭘까, 일단 <u>엔티티를 영구 저장하는 환경</u>이라는 뜻이다.

- `EntityManager.persist(entity);`

위 코드를 작성하면 매니저에서 entity를 db에 저장하는 구나 하지만, 실제론 깊은 개념이 있다. 사실 디비에 저장한다는 것이 아니라 영속성 컨텍스트를 통해서 엔티티를 영속화한다는 뜻이다. 사실 디비에 저장하는게 아니라 영속성 컨텍스트에 저장한다는 것이다.

영속성 컨텍스트는 논리적인 개념이며, 눈에 보이지 않는다. 엔티티 매니저를 통해서 영속성 컨텍스트에 저장한다.

더 설명하기전 엔티티의 생명주기가있다.

- 비영속 (new / transient): 영속성 컨텍스트와 전혀 관계가 없는 새로운 상태
- 영속 (managed): 영속성 컨텍스트에 관리되는 상태
- 준영속 (detached): 영속성 컨텍스트에 저장되었다가 분리된 상태
- 삭제 (removed): 삭제된 상태

코드로 이해해보자.

```java
Member member = new Member();
member.setId("member1");
member.setUsername("회원1");
```

여기까지 코드를 짜면 그냥 단순히 객체를 생성한 것이므로 비영속 상태이다.

```java
EntityManager em = emf.createEntityManager();
em.getTransaction().begin();

em.persist(member);
```

그리고 persist를 하게 되면 엔티티 매니저안에 있는 영속성 컨텍스트안에 member가 들어가면서 영속상태가 된다. 멤버가 이제 관리가 된다. 그리고 이 때 디비에 저장되는 것은 아니다.

```java
em.detach(member);
```

그리고 위 코드를 진행하면 준영속 상태로 관계를 끊어버린다.

```java
em.remove(member);
```

remove는 실제 디비 삭제를 요청하는 <u>상태</u>이다.

그리고 실제로 쿼리를 날리는 시점은

```java
tx.commit();
```

이라는 코드를 만나는 시점에 영속성 컨텍스트에 관리되고 있는 애들의 쿼리를 날리게 된다.



#### 그렇다면 이 영속성 컨텍스트의 이점이 도대체 뭘까?

일단 중간에 있다는 것만으로도 버퍼링, 캐싱을 누릴 수 있다. 더 자세한 장점은 다음과 같다.

- 1차 캐시
- 동일성(identity) 보장
- 트랜잭션을 지원하는 쓰기 지연(transactional write-behind)
- 변경 감지(Dirty Checking)
- 지연 로딩(Lazy Loading)



**1차 캐시**

영속성 컨텍스트는 내부에 1차 캐시라는 것을 들고 있다. 만약 내가 

```java
em.persist(member);
```

를 만나면 1차캐시 안에 다음과 같이 저장된다.

| @Id                      | Entity         |
| ------------------------ | -------------- |
| "member1" (DB Pk로 매핑한 키) | member (객체 자체) |

그리고 만약 우리가

```java
Member findMember = em.find(Member.class, "member1");
```

위 조회문을 만나면 먼저 1차 캐시를 뒤져본다. 그리고 캐시에 있는 값을 그냥 조회한다. 디비에서 가져오는 것이 아니다. 만약 근데 member2를 조회한다고 해보자. 그럼 1차 캐시에 없는 것을 확인하고 DB에 조회를 해본다. 그리고 그 엔티티를 1차 캐시에 넣어두고 반환한다. 다시 2를 조회한다면 이젠 1차캐시에서 가져오는 것이다.

근데 이게 그렇게 크게 도움은 안된다. 영속성 컨텍스트가 요청이 1개들어오고 끝나면 이 1차 캐시가 날아간다. 그래서 짧은 찰나의 순간에서만 이득이기에, 성능 이점이 그렇게 있진 않다.



**영속 엔티티의 동일성 보장**

이는 코드로 바로 이해할 수 있다.

```java
Member a = em.find(Member.class, "member1");
Member b = em.find(Member.class, "member1");
System.out.println(a == b); // true
```

자바 컬렉션에서 꺼내서 비교하는 것처럼 된다. 그리고 이는 1차 캐시가 있기 때문이기도 하다.



**트랜잭션을 지원하는 쓰기 지연**

```java
em.persist(memberA);
em.persist(memberB);
// - 1
tx.commit();
```

1번 시점까지 INSERT SQL을 DB에 보내지 않는다. 커밋하는 순간 데이터베이스에 쿼리를 날린다.

어떻게 이렇게 할까?

```java
em.persist(memberA);
```

를 쓰는 순간 1차캐시도 있지만 쓰기 지연 SQL 저장소도 있다. 그래서 1차 캐시에 엔티티를 보내는 순간 동시에 여기에 INSERT SQL을 생성해서 넣는다.

```java
em.persist(memberB);
```

이 문장을 만나면 저장소와 캐시에 또 쌓인다. 그리고 commit하는 시점에 쓰기 지연 SQL 저장소에 있던애들이 <u>flush</u>(밑에 참고)가 되면서 날아간다.

이렇게 하면 버퍼링이라는 기능을 사용할 수 있다. 만약 그때 그때 쿼리를 날린다면 최적화할 요소가 사라진다. 그리고 데이터베이스에 쿼리를 한번에 날릴 수 있다는 것이 장점이다.



**엔티티 수정 변경 감지**

```java
Member member = em.find(Member.class, 1L);
member.setName("HI");
// emp.persist(member);
```

내가 값을 꺼내오고 이름을 수정했다고 다시 persist를 할 필요가 없다. 다양한 방식으로 이해할 수 있는데 먼저 영속성 컨텍스트는 우리가 마치 Collection을 사용하는 것처럼 쓰고 싶은 것이다. 리스트안에 있는 객체를 꺼내서 이름 바꾼 후 다시 리스트에 집어 넣을 필요가 없는 것과 같다.

그렇다면 `em.update(member)` 과 같은 코드를 날려야할 것 같지만, 안해도 된다. 이는 영속성 컨텍스트에 비밀이 있다. JPA는 트랜잭션을 커밋하는 시점에 내부적으로 flush가 호출된다. 그리고 엔티티와 스냅샷을 비교한다. 다시 캐시를 그려보면 다음과 같다.

| @Id       | Entity  | 스냅샷          |
| --------- | ------- | ------------ |
| "memberA" | memberA | memberA(스냅샷) |

스냅샷은 내가 값을 읽어오는 최초 시점에 떠두는 것이다. 최초에 영속성 컨텍스트에 들어온 상태이다. 그리고 만약 내가 Entity를 변경했다고 하고, 커밋하는 시점에 스냅샷과 엔티티를 비교한다. 그리고 다르면 업데이트 쿼리를 쓰기지연 SQL저장소에 날려둔다. 그리고 나서 커밋하는 것이다.



#### flush

영속성 컨텍스트의 변경내용을 데이터베이스에 반영하는 것이 flush이다. 즉 쿼리를 날리는 것이다. 영속성 컨텍스트를 플러시하는 방법은 뭐가 있을까.

- em.flush() - 직접 호출
- 트랜잭션 커밋 - 자동 호출
- JPQL 쿼리 실행 - 자동 호출

그리고 flush를 하면 <u>캐시가 날아가는 것이 아니다.</u> 쓰기 지연 SQL 저장소에 있는것과 변경감지가 되어 디비에 반영되는 것이다. 따라서 단지 영속성 컨텍스트의 변경 내용을 db에 동기화하는 것이다.

근데 트랜잭션이라는 작업 단위가 중요하기 때문에 커밋 직전에만 동기화하면 된다.



#### 준영속 상태

- 영속 -> 준영속
- 영속 상태의 엔티티가 영속성 컨텍스트에서 분리(detached)
- 영속성 컨텍스트가 제공하는 기능을 사용 못함
- `em.detach(entity)`: 특정 엔티티만 준영속으로 전환
- `em.clear()`: 영속성 컨텍스트 안을 비워버린다.
- `em.close()`: 영속성 컨텍스트를 종료해버린다.