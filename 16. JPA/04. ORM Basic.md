# ORM Basic



- 객체와 테이블 연관관계 차이
- 객체의 참조와 테이블의 외래 키를 매핑

위의 내용을 이해해보자. 먼저 다음과 같은 용어가 있다.

- 방향(Direction): 단방향, 양방향
- 다중성(Multiplicity): 다대일(N:1), 일대다(1:N), 일대일(1:1), 다대다(N:M)
- 연관관계의 주인(Owner): 객체 양방향 연관관계는 관리 주인이 필요



#### 연관관계가 필요한 이유

객체지향 설계의 목표는 자율적인 객체들의 협력 공동체를 만드는 것이다. 예제를 중심으로 이해해보자.



#### 예제 시나리오

- 회원가 팀이 있다.
- 회원은 하나의 팀에만 소속될 수 있다.
- 회원과 팀은 다대일 관계다.

테이블 연관관계부터 생각해보면 MEMBER 테이블에 외래키로 TEAM_ID가 들어갈 것이다. 그리고 객체를 연관관계로 짜면 Member 클래스 안에 teamId라는 변수가 있을 것이다.

```java
@Entity
public class Member {

	@Id @GeneratedValue
	@Column(name = "MEMBER_ID")
	private Long id;
  
    @Column(name = "TEAM_ID")
  	private Long teamId;
  ...
}
```

대충 이런 코드가 나올 것이다. 이 코드의 문제점은 뭐가 있을까?

디비에 저장하는 코드를 보자.

```java
try{
  Team team = new Team();
  team.setName("teamA");
  em.persist(team);
  
  Member member = new Member();
  member.setUsername("member1");
  member.setTeamId(team.getId()); // 객체지향적이지 않은 부분
  em.persist(member);
  
  tx.commit();
}
```

뭔가 setTeam을 해줘야할 것 같은데 객체지향적이지 않은 느낌이다. 그리고 이렇게하면 조회할 때도 뭔가 이슈가 생긴다.

```java
Member findMember = em.find(Member.class, member.getId());
Long findTeamId = findMember.getTeamId();
Team findTeam = em.find(Team.class, findTeamId);
```

서로 연관관계가 없기 때문에 계속 물어봐야 한다. 그래서 테이블에 맞추어 데이터 중심으로 모델링하면, 협력관계를 만들 수 없다.

기본적으로 테이블은 외래 키로 조인을 해서 연관된 테이블을 찾는 반면, 객체는 참조를 이용해서 연관된 객체를 찾기 때문이다. 그래서 위를 객체 지향적으로 설계하려면 Member Class를 수정해야 한다.

```java
@Entity
public class Member {

	@Id @GeneratedValue
	@Column(name = "MEMBER_ID")
	private Long id;
  
    @ManyToOne
  	@JoinColumn(name = "TEAM_ID")
  	private Team team;
  ...
}
```

근데 그냥 Team team이라 하면 에러가 뜬다. JPA에게 어떤 관계인지 얘기를 해주어야 한다. 누가 N이고 누가 1인지를 생각해야 한다. 여기서는 Member가 n이고 team이 1이기 때문에 어노테이션을 위와 같이 붙인 것이다. 그리고 조인 컬럼을 적어주면 매핑이 된다.



#### 양방향 연관관계와 연관관계의 주인

C++의 포인터같은 부분이라고 할 수 있다. 어려우니 잘 이해해보자. 이 역시 객체와 테이블의 차이로 인해 생기는 개념이다. 위에선 단방향 연관관계였다. Member에서 팀으로는 갈 수 있었지만, Team에서 member로는 갈 수 없다. 근데 양쪽으로 갈 수 있게 만들 수 있다. 그렇게 만들면 양방향 연관관계가 된다. 그리고 테이블은 변함이 하나도 없다. 왜냐면 테이블은 외래키 하나가 있으므로 조인하면 서로 알 수 있기 때문이다.

Team에 `List<Member>` 를 넣어야 한다.

```java
@OneToMany(mappedBy = "team")
private List<Member> members = new ArrayList<>();
```

그리고 초기화 해두어야 add할때 null이 뜨지 않아서 위로 쓰는 것이 관례이다. team은 멤버에 있는 변수명이다. 어떤거랑 매핑되어 있는지를 알려야 하며, 팀 입장에서는 1:N관계 이므로 어노테이션은 위와 같다.

이젠 양방향 매핑이 된 것이다. 근데 참고로 뒤에서 정리하겠지만 객체는 단방향이 좋다. 왜냐면 양방향은 신경쓰게 될 것이 많다.

그리고 난이도를 어렵게하는 요소가 바로

```java
@OneToMany(mappedBy = "team")
```

이 부분이다. mappedBy가 왜 있어야 할까? 이론적인 이유에 대해서 이해하고 어느타이밍에 써야할지 감을 잡아보자. 먼저 객체와 테이블이 관계를 맺는 차이가 있다.

- 객체 연관관계: 2개, 우리가 억지로 2개 만들어서 양방향을 만든 것이지 정확히는 단방향 2개이다.
  - 회원 -> 팀 연관관계 1개(단방향)
  - 팀 -> 회원 연관관계 1개(단방향)
- 테이블 연관관계: 1개, 외래키 하나로 양쪽으로 조인할 수 있다.
  - 회원 <-> 팀의 연관관계 1개(양방향)

여기서 딜레마가 온다. 왜냐하면 멤버 <u>객체</u>의 Team을 바꿨을때 MEMBER <u>테이블</u>의 FK를 조정해야 할까, 아니면 팀 <u>객체</u>의 List member를 바꿨을 때 MEMBER <u>테이블</u>의 FK를 조정해야 할까? 두개 다 매핑을 해야하나? 그래서 여기서 룰이 하나 생긴다 둘 중 하나로 외래키를 관리해야 한다.



#### 연관관계의 주인(Owner)

양방향 매핑에서 나오는 것이다.

- 객체의 두 관계중 하나를 연관관계의 주인으로 지정
- **연관관계의 주인만이 외래키를 관리(등록, 수정)**
- **주인이 아닌 쪽은 읽기만 가능**
- 주인은 mappedBy 속성 사용 X
- 주인이 아니면 mappedBy 속성으로 주인 지정

누구를 주인으로 지정할까?

정답을 정하자. <u>외래 키가 있는 곳을 주인으로 정해라.</u> 그래서 가짜 매핑이 걸린 쪽은 수정해봐야 디비에 반영이 되질 않는다. 그리고 외래키의 성질까지 생각해본다면 다대일에서 다쪽이 연관관계 주인이 된다. 그래야 성능 이슈가 생기질 않고, 헷갈리지 않는다.



#### 양방향 매핑시 가장 많이 하는 실수

연관관계의 주인에 값을 입력하지 않는 것이 가장 큰 실수이다. 연관관계의 주인말고 가짜 매핑된 곳에 값을 입력하면, 무의미한 동작이기에 꼭 연관관계의 주인에 값을 입력해야 한다. 그럼 한쪽에만 넣으면 될까?

먼저, 순수한 객체 관계를 고려하면 항상 양쪽다 값을 입력해야 한다. 그리고 두가지 문제가 발생한다.

1. 일단 flush하고, clear까지하면 적용이 잘될텐데 이전에 내가 team객체를 꺼낸다고 해보자. team에는 member를 추가하지 않은 상태에서 이러면 1차캐시에서 꺼낼텐데 그럼 아직 매핑된 상태로 꺼내지지 않는다. 
2. 테스트를 작성할 때 문제가 된다. JPA없이도 순수하게 자바 코드상태로 돌아야하는데, 안맞을 것이다. 그래서 양방향 매핑관계시 양쪽에 세팅을 다 하는 것이 맞다.

그럼 매번 두개를 하기도 귀찮을 수 있다. 연관관계 편의 메서드를 작성하자.

```java
public void changeTeam(Team team){
  this.team = team;
  team.getMembers().add(this);
}
```

이렇게 작성해두면 실수할 여지도 줄어들고 좋다. 그리고 이름도 set을 change라고 바꾸어 두었다. 왜냐면 내부적인 로직이 조금 존재하기에 관례에 의한 set과는 조금 다르다는 것을 명시적으로 표현하는 것이다. 어느쪽에서 하든지 상관없다. 어쨌든 둘다 할 수 있기에,

양방향 매핑시 무한 루프를 조심하자.

예로 toString, lombok, JSON 생성 라이브러리같은 것이 있다. 서로가 서로를 호출할 수 있으므로 조심하자. lombok에서 toString 만드는 것은 쓰지 않는 것을 권장하며 써도 빼고 쓰자. JSON 생성 라이브러리는 걱정할 필요 없다. 컨트롤러에서 엔티티 자체를 절대 반환할 일이 없다. 반환해도 DTO로 반환할 테니 괜찮다.



사실 제일 중요한건 단방향 매핑이다. <u>처음에 설계할 때 단방향 매핑으로 모두 끝내야한다.</u> 양방향 매핑은 반대 방향으로 조회 기능이 추가된 것 뿐이다. 나중에 역방향으로 탐색할 일이 많긴한데, 단방향 매핑만 잘하고 양방향은 필요할 때 추가해도 된다. 테이블에 영향을 주지 않기 때문이다.