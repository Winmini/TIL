# Data Modeling and Indexing



데이터베이스에서 데이터를 다루게 되면 하드웨어 개선 없이도 속도를 향상시키는 방법이 있다. 그 가운데 대표적인 방법이 데이터 모델링과 인덱싱을 잘 하는 것이다.



### 컬렉션 사이의 관계

MongoDB가 NoSQL이기 때문에 데이터의 구조에 대한 고민을 하지 않아도 생각할 수 있는데, 이 역시 데이터를 어떻게 구성할지 전략적으로 정하지 않으면 효율적인 데이터 처리를 수행하지 못한다. 이처럼 저장할 데이터의 구조를 정하는 작업을 '데이터 모델링'이라고 한다. 데이터 모델링은 많은 양의 데이터를 빈번하게 조회하는 서비스에서 특히 중요하다.



**데이터 모델링의 예시**

다음은 만들고자 하는 커뮤니티 서비스의 예시다. 예시를 통해 데이터 모델링을 얼마나 다양하게 설계할 수 있는지 생각해보자.

1. 사용자는 이름과 생년월일, 점수를 가진다.
2. 게시판은 이름을 가진다.
3. 게시글은 사용자가 게시판에 작성 가능하고, 제목과 내용 조회수를 표시한다.
4. 조회수는 사용자당 1씩만 올릴 수 있고, 다시 게시글을 읽어도 조회수가 오르지 않는다.

전형적인 커뮤니티 서비스가 가지는 기능들이다. 이 기능을 구현하기 위해 만들 수 있는 데이터 구조는 수십 가지가 넘는다. 그 중 다음과 같이 데이터 모델링을 할 수 있다.

- 사용자 : 이름, 생년월일, 포인트
- 게시판: 이름
- 게시글: 게시판 id, 사용자 id, 제목, 내용
- 조회: 게시글 id, 사용자 id

각각은 컬렉션을 의미하고 나머지는 컬렉션이 가지는 필드를 의미한다. 잘 보면 게시글과 조회 컬렉션은 다른 컬렉션의 id를 저장해서 도큐먼트들 사이의 관계를 형성했다.

그리고 이 구조를 생각해보면 서로 컬렉션간의 관곅 일대다, 다대다 등 여러 관계가 형성된다. 그리고 이 관계에 따라 데이터베이스의 효율성이 달라진다. 그리고 MongoDB는 다양한 구조를 만들 수 있어 임베디드 방식으로도, 즉 컬렉션을 따로 두지 않고 게시판 도큐먼트 내에 게시글 도큐먼트를 넣어둘 수도 있다. 그리고 이 구조에서도 차이가 생긴다. 참고로 id로 참조하는 방식이 레퍼런스 방식이다.

|         | 레퍼런스 방식     | 임베디드 방식     |
| ------- | ----------- | ----------- |
| 도큐먼트 크기 | 작다.         | 크다.         |
| 정보의 추가  | 도큐먼트를 추가한다. | 도큐먼트를 수정한다. |



**임베디드 방식의 장점**

임베디드된 내용을 읽는 것이 레퍼런스 방식에 비해 더 빠르다. 단, 임베디드 된 대부분의 정보를 읽어햐 하는 상황일 때 더 빠르고 만약 매우 일부분의 정보를 읽어야 하는 상황일땐 읽기 성능이 오히려 더 느릴 수 있다.

단순히 하나의 서버라면 이 차이가 적지만 만약 MongoDB가 샤딩되어 있다면 속도 차이가 커진다.  관련이 되어 있는 도큐먼트를 찾기 위해 서버 사이에서 정보 교환이 몇 번이나 이루어진 후에야 읽기 작업이 마무리되기 때문이다. 그래서 빈번하게 함께 읽게 되는 정보는 임베디드 방식으로 하나의 도큐먼트에 넣는 것이 바람직하다.



**임베디드 방식의 단점**

MongoDB 도큐먼트의 크기는 16MB까지 제한되어 있다. 이 제한 때문에 임베디드 방식은 일부 상황에 적용하기 힘들다. 임베디드되는 정보의 양이 한정적이라면 문제가 없지만, 무한정 추가될 수 있다면 정해진 크기를 초과하는 문제가 생길 것이다.

정보를 추가하거나 수정할 때 임베디드 방식은 도큐먼트를 수정해야 한다. 도큐먼트의 크기가 클 경우 그 많은 정보를 모두 램 메모리에 읽어 들인 후 수정이 이루어지기 때문에 속도가 느려진다. 또한 복제가 이루어져 있는 상황이라면 수정되는 도큐먼트 내의 모든 정보를 자신의 서버와 복제된 정보를 가져야 하는 서버에 보내기 때문에 더 비효율적이다. 따라서 도큐먼트 크기를 100kb 이하의 상태로 유지하는 것을 추천한다.

참고로 임베디드 방식은 중복된 정보를 허용하여 중복된 만큼 데이터 베이스의 용량을 낭비할 수 있다. 물론 중복에서 오는 손해보다 읽기 속도를 향상시키는 이점이 훨씬 크다고는 한다.



### 인덱싱

인덱스의 기본 특징은 다음과 같다.

1. 쿼리를 수행할 때 인덱스가 없다면 모든 도큐먼트를 일일이 조회해야 한다. 인덱스는 쿼리 작업을 매우 효율적으로 만든다.
2. 하지만 인덱스를 만들면 새로운 도큐먼트를 생성하거나 제거하는 작업을 빈번하게 할 때 속도의 저하가 일어날 수 있다. 매번 인덱스를 업데이트해야 하기 때문이다.
3. 단순 인덱스를 만들면 필드만 조회할 때 사용하고, 다수의 필드를 대상으로 조회할 때엔 복합 인덱스가 필요하다.
4. 복합 인덱스는 순서가 중요하다.





**인덱스의 구조**

MongoDB에서는 인덱스를 어떤 필드에 대한 값을 검색하기 쉽도록 그 필드의 값들을 B-Tree구조로 만들어서 저장한다. 이때 인덱스를 만들기 위해 기준으로 삼은 필드의 값들을 '인덱스 키'라고 부른다. 참고로 MongoDB에선 _id필드가 특히 도큐먼트에 대해 각각 하나의 값을 가진다. 이래서 이 필드 값을 기본키라고 한다. 이는 우리가 직접 인덱스를 생겅하지 않아도 컬렉션이 생성될 때 자동으로 인덱스가 생성된다.

MongoDB는 기본적으로 B-Tree라는 자료구조를 이용한다. 트리인데 하나의 노드에 두 개 이상읮 ㅏ식노드를 가지며, 노드에 있는 키들은 전부 정렬되어 있어야 한다. 만약 인덱스에 새로운 정보를 추가하거나 삭제하게 될 때 인덱스는 어떻게 정리할까?

단순하게 생각하면 노드 사이에 값을 끼워넣을 것 같지만 그렇지 않다. 사실 트리 구조에서 자식 노드를 엄청 많이 만들거나, 반대로 하나의 노드에 키 값이 적게 들어있게 된다면 검색 효율이 떨어지게 된다. 검색할 때 가장 적은 횟수의 조회를 하도록 정해진 규칙에 맞춰서 인덱스를 정리해야 한다. 이런 과정을 '균형 맞춤'이라고 한다. 때문에 정말 필요한 인덱스가 아니면 함부로 생성하지 않는 것이 좋고 생성 및 삭제 작업이 빈번하다면 인덱스를 만들지 않는 것도 때로는 고려해보아야 한다.