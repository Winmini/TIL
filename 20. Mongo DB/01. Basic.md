# Basic



라인 플러스 면접으로 NoSQL에 대한 질문이 들어왔다. 평소에 잘 공부하지 않았던 분야이고, 언젠간 해야지 하고 미뤄놨던 과목인데 대답을 못해서 이참에 하기로 마음먹었다.

NoSQL은 SQL이 아닌, DBMS를 뜻한다. 관계형 DBMS인 RDBMS에 반발하는 의미도 담겨있다고 한다. 관계형만 아니면 모두 NoSQL이고, 그런 NoSQL에서 꽤 인기있는 Mongo DB책이 집에 있어서 공부해보자.



NoSQL DBMS도 4가지로 분류할 수 있다.

| 종류          | 예시               |
| ----------- | ---------------- |
| 키-값 스토어     | Redis, Dynamo    |
| 컬럼 지향 스토어   | HBase, Cassandra |
| 도큐먼트 지향 스토어 | MongoDB          |
| 그래프 데이터베이스  | Neo4J            |

왜 관계형을 포기했을까?

기존 관계형 DB 규칙 일부를 포기하는 대신, 뛰어난 확장성이나 성능을 발전시키는 방향으로 개선되기 위함이다.



 #### 왜 인기가 있을까?

**빠른 속도와 확장성**

사용되고 있는 DBMS 중 대다수의 경우 `SQL(Structured Query Language)` 이라는 언어를 사용해서 정보를 불러오거나 관리해야 한다. `SQL`은 관계형 데이터베이스 관리 시스템을 위해 특수 설계된 언어이므로, 데이터베이스에 질의하기 위한 목적이 아니라면 거의 사용할 일이 없다. 그러나 MongoDB는 사용자에게 친숙하게 다가가기 위해 웹 개발자라면 한 번쯤은 사용해 봤을 JavaScript를 활용하고 있다. 그리고 구조도 한번 확인해보자.

기존 관계형 모델은 다음과 같다.

| id   | 이름   | 물품번호 |
| ---- | ---- | ---- |
| 1    | mike | 4    |
| 2    | miki | 5    |
| 3    | milk | 6    |

그리고 MongoDB 모델은 다음과 같다.

{id: 1, 이름: 'mike', 물품번호: 4}

{id: 2, 이름: 'miki', 물품번호: 5}

{id: 3, 이름: 'milk', 물품번호: 6}

하나는 박스에 담아둔 느낌, 하나는 그냥 글을 써놓은 느낌을 준다. 근데 만약 이 상황에서 기존에는 물품을 한 사람당 하나만 가지고 있었지만, 두 개 이상의 물품을 한 사람이 가질 수 있게 구조를 바꿔야 한다면, 도식은 어떻게 변할까?

관계형 모델은 "테이블"이라는 틀이 있기 때문에 새로운 테이블을 생성하고 두 테이블 사이의 관계를 정의하는 컬럼을 추가해서 표현할 수밖에 없다. 다음과 같이 말이다.

| id   | 이름   |
| ---- | ---- |
| 1    | mike |
| 2    | miki |
| 3    | milk |

| id   | 명단id | 물품번호 |
| ---- | ---- | ---- |
| 1    | 1    | 4    |
| 2    | 1    | 3    |
| 3    | 2    | 5    |
| 4    | 3    | 6    |

그리고 이 두 테이블을 조인해서 얻어오거나 해야한다. 근데 MongoDB는 

{id: 1, 이름: 'mike', 물품번호: [4,3]}

이렇게 바꾸는 것으로 끝난다. 즉, 크기는 얼마나 될지, 어떤 값을 가질지 미리 정하지 않고**(Schemaless)** 데이터를 저장할 수 있다.



MongoDB의 또 하나의 장점은 바로 **복제(Replicate)**와 **샤딩(Sharding)**을 기본적인 DBMS의 기능으로 제공하고 있다는 점이다.



**복제**

무료 송금 애플리케이션을 개발하는데 계좌정보를 MongoDB에 저장한다고 가정해보자. 근데 데이터베이스 서버 하나가 갑자기 정전이 일어나서 송금 시스템이 통째로 멈추면 어떤 일이 벌어질까? 당연히 이런일은 발생해선 안된다. 애플리케이션은 안정성이 매우 중요하다. 때문에 데이터를 불러오는 데 실패하지 않으려면 복제가 중요하다. 어떠한 문제가 생겨도 복제된 데이터베이스가 있다면 이것들을 연결시켜 데이터 흐름을 복구할 수 있다.



**샤딩**

데이터베이스에 저장된 정보의 양이 많아지고, 읽고 쓰는 양이 많아지면 필연적으로 DB에 서 작업을 수행하는 속도는 느려진다. 이런 상황에서 향상시키는 방법은 정부를 문산해서 여러 대의 서버 DB에 저장하는 것이다. 이렇게 정보를 분산해서 저장하는 방식을 샤딩이라고 한다.



애초에 MongoDB는 기존 관계형 규칙을 엄격하게 적용하지 않아서 복제와 샤딩을 그냥 기본적으로 제공하는 기능만으로 쉽게 구성할 수 있다. 그리고 실은, MongoDB는 이보다 한 발 더 나아가 복제와 샤딩을 의식하고 만들어서 이 두 기능에 맞춰 설계했다고 생각해도 무방하다.



### 그럼 언제 사용할까?

개발자가 어떤 기술을 배우고 적용할 때는 그 기술이 상황에 적합한지 인지해야 한다. 항상 정답은 없으며 그때마다 기술을 골라야 한다. 그래서 MongoDB역시 필요한 순간에 골라야 한다. 다음을 고려하자.

- **스키마가 자주 바뀌는 환경**

스키마란 어떤 종류의 정보를 어떤 구조에 어떤 관계를 가지고 있는지 정의한 구조를 말한다. 어떻게 스키마를 구성하는지에 따라 데이터베이스의 효율성이 달라지기도 하고, 개발자가 자료가 저장된 구조를 더 잘 이해할 수 있기도 하다.

MongoDB는 앞서 설명했듯이 도큐먼트 지향 스토어 방식을 채택하고 있어, 스키마의 변경이 비교적 자유로운 편이다. 만약 추가될 기능이 확실하지 않고 상황에 따라 애플리케이션에 저장될 자료가 지속적으로 달라지는 개발 방법론을 개발할 예정이라면, 선택하기 좋다. 최종적인 개발 명세가 확정되지 않는 상황을 말한다.

- **분산 컴퓨팅 환경**

MongoDB는 상대적으로 큰 노력을 들이지 않고도, 여러 대의 서버에 데이터베이스를 나누는 분산 컴퓨팅 환경을 만들 수 있다. 샤딩과 복제를 DBMS 수준에서 지원해서 여러 관련 기능들을 보다 효과적으로 적용할 수 있다. 그럼 다시 고민해야 한다. 샤딩과 복제가 필요한 순간은 언제일까?



복제는 '고가용성'환경이 필요할 때 고려해볼만 하다. 고가용성이란 항상 사용할 수 있는 상태를 말한다. 다양한 상황에서도 원하는 데이터를 얻는 환경이라고할 수 있다. 또한 복제된 서버에서도 읽기 기능을 하도록 설정할 수 있기 때문에 만약 내 서비스가 읽기 속도가 많이 필요하다면, 복제를 통해 읽기 속도를 향상시키는 방법도 있다.

샤딩은 저장 용량이 늘어나면서 읽기, 쓰기 속도가 필요한 만큼 나오지 않을 때 고려할 수 있다. 흔히 서비스의 사용자가 많이 늘어난 상황일 때 이런 경우가 많다. 속도를 향상 시키는 방법으론, 최적화도 해보고, 부족하다며녀 단일 서버의 성능을 향상시킨다. 그러다 어느 순간 단일 서버의 성능을 높이는 것보다 샤딩을 통해서 서버를 둘로 나누는 비용이 저렴해지는 시점이 생긴다. 그때 샤딩을 하면 된다.